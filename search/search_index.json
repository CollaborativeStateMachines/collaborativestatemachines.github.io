{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Collaborative State Machines (CSM) is a programming model for building reactive, distributed applications that run across the cloud, edge, and IoT . Traditional programming models often struggle with applications that are dynamic, stateful, and spread across the cloud, edge, and IoT . CSM addresses this by letting you design applications as collections of state machines that collaborate with each other . Each state machine can run in the cloud, at the edge, or directly on IoT devices, yet all machines continue to operate together as one cohesive system. About us CSM is developed by the Distributed and Parallel Systems Group at the University of Innsbruck. Learn more about our research and meet the team . How it works At the heart of CSM are state machines . Each one is small, autonomous, and easy to reason about. Together, they form powerful distributed applications. State machines can: React to events from their environment or from other machines. Maintain their own state , while also working with persistent shared data. Trigger actions or external services directly inside states and transitions. Collaborate by exchanging events and data with other machines. This approach makes complex logic easier to manage without tying your application to specific compute nodes, services, or execution environments. Learn more about the fundamental programming model through the CSM specifications . Why use CSM? CSM helps developers tackle complexity with: Resilience \u2014 applications adapt to changing environments and recover from failures. Modularity \u2014 behavior is encapsulated, making systems easier to understand and extend. True distribution \u2014 run across cloud, edge, and IoT without extra complexity. Separation of concerns \u2014 cleanly express application logic, decoupled from infrastructure. Structured data management \u2014 handle local, static, and persistent data with well-defined scope and lifetime. Learn more about getting started . What can you build? CSM is ideal for any system that is distributed, event-driven, and stateful . Examples include: IoT & Edge Solutions \u2014 devices reacting to local events while syncing with cloud services. Surveillance & Monitoring \u2014 distributed data streams processed in real time. Smart Factories \u2014 workflows coordinating machines, sensors, and analytics. Large-Scale Cloud Systems \u2014 scalable applications with clear separation of business logic and infrastructure. For more, see our examples .","title":"Home"},{"location":"#about-us","text":"CSM is developed by the Distributed and Parallel Systems Group at the University of Innsbruck. Learn more about our research and meet the team .","title":"About us"},{"location":"#how-it-works","text":"At the heart of CSM are state machines . Each one is small, autonomous, and easy to reason about. Together, they form powerful distributed applications. State machines can: React to events from their environment or from other machines. Maintain their own state , while also working with persistent shared data. Trigger actions or external services directly inside states and transitions. Collaborate by exchanging events and data with other machines. This approach makes complex logic easier to manage without tying your application to specific compute nodes, services, or execution environments. Learn more about the fundamental programming model through the CSM specifications .","title":"How it works"},{"location":"#why-use-csm","text":"CSM helps developers tackle complexity with: Resilience \u2014 applications adapt to changing environments and recover from failures. Modularity \u2014 behavior is encapsulated, making systems easier to understand and extend. True distribution \u2014 run across cloud, edge, and IoT without extra complexity. Separation of concerns \u2014 cleanly express application logic, decoupled from infrastructure. Structured data management \u2014 handle local, static, and persistent data with well-defined scope and lifetime. Learn more about getting started .","title":"Why use CSM?"},{"location":"#what-can-you-build","text":"CSM is ideal for any system that is distributed, event-driven, and stateful . Examples include: IoT & Edge Solutions \u2014 devices reacting to local events while syncing with cloud services. Surveillance & Monitoring \u2014 distributed data streams processed in real time. Smart Factories \u2014 workflows coordinating machines, sensors, and analytics. Large-Scale Cloud Systems \u2014 scalable applications with clear separation of business logic and infrastructure. For more, see our examples .","title":"What can you build?"},{"location":"getting-started/","text":"Pending.","title":"Getting started"},{"location":"cirrina/contributing/","text":"Pending.","title":"Contributing"},{"location":"cirrina/runtime-system/","text":"Pending.","title":"Runtime system"},{"location":"csm/examples/","text":"Pending.","title":"Examples"},{"location":"csm-specifications/action/","text":"Action-related constructs are described below. InvokeAction An invoke action allows a state machine to call a defined service type . The term 'type' in 'service type' refers to the CSM service abstraction. Invoking a service type does not specify a particular implementation. Instead, a service type may represent multiple variants of a service, which can differ in algorithm, resource optimization, or approximate computation methods to reduce costs. The runtime system selects the specific implementation based on available context, such as user or environmental information, to optimize for performance or other objectives. Input data for a service invocation can be provided through one or more expressions specified with the input keyword. To handle actions executed after the service completes, done events can be declared. These events provide access to the service's output data, which can be stored, passed to subsequent invocations or events, or used in other actions. Setting the local keyword to true signals the runtime system to invoke the service locally, on the same resource as the state machine, if possible. If omitted or set to false, the service may be invoked remotely on a different resource. new InvokeAction { serviceType = \"serviceTypeName\" local = false input = new Data {...} output = new Data {...} done { new Event {...}... } } Listing 11: An InvokeAction construct. The following keywords can/must be provided: Keyword Description Type Optional type Type of action. string No serviceType Service type name. string No local Local execution flag. boolean Yes input Input data. list of Variable Yes output Output data reference. list of VariableReference Yes done Done events. list of Event Yes serviceType The serviceType keyword specifies the invoked service type. The service type is provided as a string value. The validity of the service type is implementation-specific. local The local keyword provides a hint to the runtime system implementation that the service type is intended to be invoked locally, in case of boolean true. Otherwise, it is not specified where the runtime system implementation should invoke the service type. input The input keyword specifies the input to the invoked service type. output The output keyword specifies context variables where the output of the invoked service type should be stored. This is done by matching context variables received as output from the service invocation with the output references defined using this keyword. Variable references can be local, static or persistent context variables. done The done keyword specifies the events raised after invocation. Raising done events allows for asynchronous service type invocation, allow transitioning into subsequent states whenever the service type invocation has been completed. CreateAction / AssignAction / DeleteAction Data manipulation actions enable the dynamic creation of variables as local or persistent data, the assignment of values to existing variables, and the deletion of variables. When creating a variable, the persistent keyword is used to specify whether the variable should be created persistently. In case the keyword is omitted or has the value false, the variable is locally created in the current scope. new CreateAction { variable = new Variable {...} persistent = true } new AssignAction { variable = new VariableReference {...} value = new Expression {...} } new DeleteAction { variable = new VariableReference {...} } Listing 12: A CreateAction, AssignAction, and DeleteAction construct. The following keywords can/must be provided (create action construct): Keyword Description Type Optional variable Variable to create. Variable No persistent Whether to create data persistently. boolean Yes The following keywords can/must be provided (assign action construct): Keyword Description Type Optional variable Variable reference to assign to. VariableReference No value Value expression. Expression No The following keywords can/must be provided (delete action construct): Keyword Description Type Optional variable Variable reference to delete. VariableReference No variable The variable keyword specifies the variable to create or the variable reference to manipulate. When creating a variable, the variable must not exist. When manipulating an existing variable, the variable must exist. persistent The persistent keyword specifies, for a create action, whether the variable needs to be created persistently. In case it must, the variable is created in the persistent data. Otherwise, the variable is locally created in the current scope. value The value keyword specifies the value expression for an assign action. The expression is evaluated to acquire the data value assigned to the variable. RaiseAction new RaiseAction { event = new Event { ... } } Listing 13: A raise event action construct. The raise event action enables a state machine to raise an event that is subsequently handled by another state machine or the state machine itself. The following keywords can/must be provided (raise action construct): Keyword Description Type Optional event The event to raise. Event No event The event specifies the event to raise within the collaborative state machine. TimeoutAction / TimeoutResetAction new TimeoutAction { name = \"timeout\" delay = new Expression {...} action = new RaiseAction {...} } new TimeoutResetAction { action = \"timeout\" } Listing 14: A timeout and timeout reset action construct. A special type of action, the timeout action, is used together with the after keyword. The timeout action specifies a delay, after which the specified action is executed. The provided action must be a raise event action so subsequent behavior can be triggered upon a raised event. Timeouts can be reset based on the reset timeout action. The following keywords can/must be provided (timeout action construct): Keyword Description Type Optional name The timeout action name. string No delay The event to raise. Expression No action The action to execute upon timeout. RaiseAction No The following keywords can/must be provided (timeout reset action construct): Keyword Description Type Optional action The timeout action to reset. TimeoutAction.name No name The name keyword specifies the name of the timeout action used to reference the timeout action for resetting. The validity of an action name is implementation-specific. delay The delay keyword specifies the delay expression evaluated to provide the delay value. The delay value is specified in milliseconds. The delay expression must be evaluated to a numeric value. action For a timeout action, the action keyword specifies the action to execute upon the timeout. The action provided must be a raised event action. The actions provided as timeout actions must be raise event actions. For a timeout reset action, the action keyword specifies the timeout action to reset. The action referenced must be a previously executed timeout action. The action reference provided must be a previously executed timeout action.","title":"Action"},{"location":"csm-specifications/action/#invokeaction","text":"An invoke action allows a state machine to call a defined service type . The term 'type' in 'service type' refers to the CSM service abstraction. Invoking a service type does not specify a particular implementation. Instead, a service type may represent multiple variants of a service, which can differ in algorithm, resource optimization, or approximate computation methods to reduce costs. The runtime system selects the specific implementation based on available context, such as user or environmental information, to optimize for performance or other objectives. Input data for a service invocation can be provided through one or more expressions specified with the input keyword. To handle actions executed after the service completes, done events can be declared. These events provide access to the service's output data, which can be stored, passed to subsequent invocations or events, or used in other actions. Setting the local keyword to true signals the runtime system to invoke the service locally, on the same resource as the state machine, if possible. If omitted or set to false, the service may be invoked remotely on a different resource. new InvokeAction { serviceType = \"serviceTypeName\" local = false input = new Data {...} output = new Data {...} done { new Event {...}... } } Listing 11: An InvokeAction construct. The following keywords can/must be provided: Keyword Description Type Optional type Type of action. string No serviceType Service type name. string No local Local execution flag. boolean Yes input Input data. list of Variable Yes output Output data reference. list of VariableReference Yes done Done events. list of Event Yes","title":"InvokeAction"},{"location":"csm-specifications/action/#servicetype","text":"The serviceType keyword specifies the invoked service type. The service type is provided as a string value. The validity of the service type is implementation-specific.","title":"serviceType"},{"location":"csm-specifications/action/#local","text":"The local keyword provides a hint to the runtime system implementation that the service type is intended to be invoked locally, in case of boolean true. Otherwise, it is not specified where the runtime system implementation should invoke the service type.","title":"local"},{"location":"csm-specifications/action/#input","text":"The input keyword specifies the input to the invoked service type.","title":"input"},{"location":"csm-specifications/action/#output","text":"The output keyword specifies context variables where the output of the invoked service type should be stored. This is done by matching context variables received as output from the service invocation with the output references defined using this keyword. Variable references can be local, static or persistent context variables.","title":"output"},{"location":"csm-specifications/action/#done","text":"The done keyword specifies the events raised after invocation. Raising done events allows for asynchronous service type invocation, allow transitioning into subsequent states whenever the service type invocation has been completed.","title":"done"},{"location":"csm-specifications/action/#createaction-assignaction-deleteaction","text":"Data manipulation actions enable the dynamic creation of variables as local or persistent data, the assignment of values to existing variables, and the deletion of variables. When creating a variable, the persistent keyword is used to specify whether the variable should be created persistently. In case the keyword is omitted or has the value false, the variable is locally created in the current scope. new CreateAction { variable = new Variable {...} persistent = true } new AssignAction { variable = new VariableReference {...} value = new Expression {...} } new DeleteAction { variable = new VariableReference {...} } Listing 12: A CreateAction, AssignAction, and DeleteAction construct. The following keywords can/must be provided (create action construct): Keyword Description Type Optional variable Variable to create. Variable No persistent Whether to create data persistently. boolean Yes The following keywords can/must be provided (assign action construct): Keyword Description Type Optional variable Variable reference to assign to. VariableReference No value Value expression. Expression No The following keywords can/must be provided (delete action construct): Keyword Description Type Optional variable Variable reference to delete. VariableReference No","title":"CreateAction / AssignAction / DeleteAction"},{"location":"csm-specifications/action/#variable","text":"The variable keyword specifies the variable to create or the variable reference to manipulate. When creating a variable, the variable must not exist. When manipulating an existing variable, the variable must exist.","title":"variable"},{"location":"csm-specifications/action/#persistent","text":"The persistent keyword specifies, for a create action, whether the variable needs to be created persistently. In case it must, the variable is created in the persistent data. Otherwise, the variable is locally created in the current scope.","title":"persistent"},{"location":"csm-specifications/action/#value","text":"The value keyword specifies the value expression for an assign action. The expression is evaluated to acquire the data value assigned to the variable.","title":"value"},{"location":"csm-specifications/action/#raiseaction","text":"new RaiseAction { event = new Event { ... } } Listing 13: A raise event action construct. The raise event action enables a state machine to raise an event that is subsequently handled by another state machine or the state machine itself. The following keywords can/must be provided (raise action construct): Keyword Description Type Optional event The event to raise. Event No","title":"RaiseAction"},{"location":"csm-specifications/action/#event","text":"The event specifies the event to raise within the collaborative state machine.","title":"event"},{"location":"csm-specifications/action/#timeoutaction-timeoutresetaction","text":"new TimeoutAction { name = \"timeout\" delay = new Expression {...} action = new RaiseAction {...} } new TimeoutResetAction { action = \"timeout\" } Listing 14: A timeout and timeout reset action construct. A special type of action, the timeout action, is used together with the after keyword. The timeout action specifies a delay, after which the specified action is executed. The provided action must be a raise event action so subsequent behavior can be triggered upon a raised event. Timeouts can be reset based on the reset timeout action. The following keywords can/must be provided (timeout action construct): Keyword Description Type Optional name The timeout action name. string No delay The event to raise. Expression No action The action to execute upon timeout. RaiseAction No The following keywords can/must be provided (timeout reset action construct): Keyword Description Type Optional action The timeout action to reset. TimeoutAction.name No","title":"TimeoutAction / TimeoutResetAction"},{"location":"csm-specifications/action/#name","text":"The name keyword specifies the name of the timeout action used to reference the timeout action for resetting. The validity of an action name is implementation-specific.","title":"name"},{"location":"csm-specifications/action/#delay","text":"The delay keyword specifies the delay expression evaluated to provide the delay value. The delay value is specified in milliseconds. The delay expression must be evaluated to a numeric value.","title":"delay"},{"location":"csm-specifications/action/#action","text":"For a timeout action, the action keyword specifies the action to execute upon the timeout. The action provided must be a raised event action. The actions provided as timeout actions must be raise event actions. For a timeout reset action, the action keyword specifies the timeout action to reset. The action referenced must be a previously executed timeout action. The action reference provided must be a previously executed timeout action.","title":"action"},{"location":"csm-specifications/background/","text":"Collaborative State Machines (CSM) is a distributed programming model for the computing continuum 1 . It represents distributed applications as state machines that can be deployed across resources throughout the continuum. The model is designed for reactive, stateful, and highly dynamic applications that must operate in heterogeneous environments. While CSM defines the abstract programming model, its applications are expressed in the associated language, CSML. Like the model itself, CSML is abstract and can be realized in different ways, for example through serialization formats or domain-specific languages. In these specifications, we describe CSML and the CSM concepts using the Pkl -based implementation of CSML employed by the official runtime system, Cirrina . Within CSML a description consists of constructs , such as those describing a collaborative state machine, state machine and state. A construct consists of one or multiple keywords . CSM description Figure 1: An example of a CSM description. Components can have data represented by {...}. CSML is used to create CSM descriptions . A description represents the static structure of an application that is executable by a CSM runtime system. A CSM description takes the form of a tree structure. At its root is a collaborative state machine , encompassing one or more state machines . A state machine contains one or more states . These fundamental entities, collaborative state machine, state machines, and states, are called components . Every component can declare local and persistent (globally accessible) data. Figure 1 above illustrates a CSM tree structure. The presented collaborative state machine has two state machines, $SM_1$ and $SM_2$, along with a nested state machine denoted as $SM_{21}$. Every state machine has two atomic states . The data variables of all components are represented by $a, \\ldots, h$. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" }); We refer to the computing continuum as the infrastructure spanning cloud, edge, and IoT layers. \u21a9","title":"Background"},{"location":"csm-specifications/background/#csm-description","text":"Figure 1: An example of a CSM description. Components can have data represented by {...}. CSML is used to create CSM descriptions . A description represents the static structure of an application that is executable by a CSM runtime system. A CSM description takes the form of a tree structure. At its root is a collaborative state machine , encompassing one or more state machines . A state machine contains one or more states . These fundamental entities, collaborative state machine, state machines, and states, are called components . Every component can declare local and persistent (globally accessible) data. Figure 1 above illustrates a CSM tree structure. The presented collaborative state machine has two state machines, $SM_1$ and $SM_2$, along with a nested state machine denoted as $SM_{21}$. Every state machine has two atomic states . The data variables of all components are represented by $a, \\ldots, h$. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" }); We refer to the computing continuum as the infrastructure spanning cloud, edge, and IoT layers. \u21a9","title":"CSM description"},{"location":"csm-specifications/collaborative-state-machine/","text":"Collaborative state machine-related constructs are described below. CollaborativeStateMachine Within CSM, state machines are inspired by David Harel's statecharts. Their primary role is to exhibit autonomous, reactive behavior through state transitions. Actions can occur during transitions, upon entering or exiting a state, or while residing in a state. These actions may include invoking computational services, manipulating data, or raising events. A collaborative state machine extends beyond single state machines by modeling an application as a collection of one or more state machines distributed across the computing continuum. State machines collaborate by raising and handling events and by sharing data. CSM defines a data model that includes persistent, local, and static data. Local and persistent data are declared through variables. Data declared within a component description is lexically declared, meaning it is created as part of the description itself, rather than dynamically generated through actions (see data model ). Variable values are determined by evaluating expressions. The memory mode defines how state machines may be distributed across the computing continuum. A collaborative state machine operates in one of two memory modes: shared or distributed . In shared memory mode, all state machines reside on the same computing resource and share memory. In distributed memory mode, state machines can execute on separate resources, each with private memory. These components run on a distributed computing infrastructure. Single state machines always operate in shared memory mode. Choosing between distributed and shared memory modes has significant implications. Distributed memory enables greater parallelism, scalability, replication, and decentralization, but may increase data transfer times when state machines on different resources need to exchange data. For more details, see the data model description. new CollaborativeStateMachine { name = \"CSM\" version = \"2.0\" memoryMode = \"distributed\" stateMachines { new StateMachine {...}... } localData = new Data {...} persistentData = new Data {...} } Listing 6: A CollaborativeStateMachine construct. The following keywords can/must be provided: Keyword Description Type Optional name Name of the collaborative state machine. string No version CSML version. version No memoryMode Memory mode. memoryMode No stateMachines Collection of state machines. list of StateMachine No localData Local data. data Yes persistentData Persistent data. data Yes name The name keyword specifies the name of the collaborative state machine. The name of the collaborative state machine is not referenced within the collaborative state machine and only serves to identify the collaborative state machine among other collaborative state machines. The validity of a collaborative state machine name is implementation-specific. version The version keyword specifies the CSML version used within a description and is used to ensure backward-compatibility. The CSML version is bound to a version of these specifications. The version is a string enumeration and must be one of the following: 1.0 2.0 3.0 A runtime system implementation's support for different CSML versions is implementation-specific. memoryMode The memoryMode keyword specifies the memory mode of the complete collaborative state machine. The memory mode applies to the entire collaborative state machine. The memory mode is a string enumeration and must be one of the following: distributed shared stateMachines The stateMachines keyword is used to specify the collection of state machines included in the collaborative state machine. At least one state machine must be declared. localData / persistentData The localData and persistentData keywords allow for lexically declaring respectively the local and persistent data of the collaborative state machine. Depending on the memory mode of the collaborative state machine, either or both types of data will be accessible within the collaborative state machine, see dynamic extent . MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"Collaborative State Machine"},{"location":"csm-specifications/collaborative-state-machine/#collaborativestatemachine","text":"Within CSM, state machines are inspired by David Harel's statecharts. Their primary role is to exhibit autonomous, reactive behavior through state transitions. Actions can occur during transitions, upon entering or exiting a state, or while residing in a state. These actions may include invoking computational services, manipulating data, or raising events. A collaborative state machine extends beyond single state machines by modeling an application as a collection of one or more state machines distributed across the computing continuum. State machines collaborate by raising and handling events and by sharing data. CSM defines a data model that includes persistent, local, and static data. Local and persistent data are declared through variables. Data declared within a component description is lexically declared, meaning it is created as part of the description itself, rather than dynamically generated through actions (see data model ). Variable values are determined by evaluating expressions. The memory mode defines how state machines may be distributed across the computing continuum. A collaborative state machine operates in one of two memory modes: shared or distributed . In shared memory mode, all state machines reside on the same computing resource and share memory. In distributed memory mode, state machines can execute on separate resources, each with private memory. These components run on a distributed computing infrastructure. Single state machines always operate in shared memory mode. Choosing between distributed and shared memory modes has significant implications. Distributed memory enables greater parallelism, scalability, replication, and decentralization, but may increase data transfer times when state machines on different resources need to exchange data. For more details, see the data model description. new CollaborativeStateMachine { name = \"CSM\" version = \"2.0\" memoryMode = \"distributed\" stateMachines { new StateMachine {...}... } localData = new Data {...} persistentData = new Data {...} } Listing 6: A CollaborativeStateMachine construct. The following keywords can/must be provided: Keyword Description Type Optional name Name of the collaborative state machine. string No version CSML version. version No memoryMode Memory mode. memoryMode No stateMachines Collection of state machines. list of StateMachine No localData Local data. data Yes persistentData Persistent data. data Yes","title":"CollaborativeStateMachine"},{"location":"csm-specifications/collaborative-state-machine/#name","text":"The name keyword specifies the name of the collaborative state machine. The name of the collaborative state machine is not referenced within the collaborative state machine and only serves to identify the collaborative state machine among other collaborative state machines. The validity of a collaborative state machine name is implementation-specific.","title":"name"},{"location":"csm-specifications/collaborative-state-machine/#version","text":"The version keyword specifies the CSML version used within a description and is used to ensure backward-compatibility. The CSML version is bound to a version of these specifications. The version is a string enumeration and must be one of the following: 1.0 2.0 3.0 A runtime system implementation's support for different CSML versions is implementation-specific.","title":"version"},{"location":"csm-specifications/collaborative-state-machine/#memorymode","text":"The memoryMode keyword specifies the memory mode of the complete collaborative state machine. The memory mode applies to the entire collaborative state machine. The memory mode is a string enumeration and must be one of the following: distributed shared","title":"memoryMode"},{"location":"csm-specifications/collaborative-state-machine/#statemachines","text":"The stateMachines keyword is used to specify the collection of state machines included in the collaborative state machine. At least one state machine must be declared.","title":"stateMachines"},{"location":"csm-specifications/collaborative-state-machine/#localdata-persistentdata","text":"The localData and persistentData keywords allow for lexically declaring respectively the local and persistent data of the collaborative state machine. Depending on the memory mode of the collaborative state machine, either or both types of data will be accessible within the collaborative state machine, see dynamic extent . MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"localData / persistentData"},{"location":"csm-specifications/data-model/","text":"Figure 1 (repeated): An example of a CSM description. Components can have data represented by {...}. The scoping of local data within a collaborative state machine is defined with respect to the dynamic extent of the components of $C$ with shared memory. We denote the dynamic extent of a component $c$ as $c^+$ to include the component itself and any ancestor of $c$. When operating in shared memory mode, $C$ is guaranteed to execute on a single resource with shared memory such that any component $c \\in C$ can access local data according to $c^+$ and $c_0^+$ where $c_0$, the root level, denotes the collaborative state machine. The root of a collaborative state machine in distributed memory mode has no shared memory and thus cannot declare or access local data. A state machine $s$ with its nested components $s_{c}$ always operates in shared memory even if $s$ is part of $C$ in distributed memory. $s$ has access to local data according to $s^+$. Similarly, each component $s_{c}$ has a dynamic extent denoted by $s_{c^+}$, allowing access to its local data within its specific scope, as illustrated in Figure 1. Restricting the access of data to ancestors facilitates information hiding. For example, a state can access the data of its parent state machine, but a state machine cannot access the data of its states or nested state machines. In Figure 1 state $S_{e}$ has access to variables $h$ and $b$, state $S_a$ can access $a$, and state $S_b$ can access variables $c$, $d$, $e$, and $a$. However, $SM_2$ can only access variable $b$. Siblings do not have access to each other's data. For instance, $S_{d}$ cannot access any data within $SM_{21}$ or $S_{c}$. When referencing an existing variable within a component $c$, the variable is located by searching within the dynamic extent $c^+$, which encompasses the local data of $c$ and extends to include any ancestor components of $c$. The search proceeds from the local data of $c$ to the local data of its ancestors, and finally to persistent data accessible to the component and its ancestors. Within CSM, data plays a multifaceted role. Data may be declared lexically or created dynamically, and data can be manipulated through actions. Data may be stored locally within a component or persisted globally. Expressions provide fundamental data transformation operations, such as selecting properties from objects, performing calculations or filtering, and invoking utility functions. The versatility of expressions extends to their usage in diverse scenarios. For example, expressions can facilitate gathering input data for service invocations, express guard conditions, or be instrumental in manipulating data objects directly. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"Data Model"},{"location":"csm-specifications/data/","text":"Data-related constructs are described below. Data A Data construct is used to lexically declare data within a certain scope (see dynamic extent ), data may be persistent , local , or static . Persistent data is available persistently throughout and possibly outside the collaborative state machine. Local data is restricted to a subset of components of the collaborative state machine. Static data is specific to states. new Data { variables { new Variable {...}... } } Listing 1: A Data construct (we use ... to denote a placeholder for construct keywords, or multiple instances of a construct). The value of a variable is defined through an expression. In Listing 1, the integer value 1 is obtained from the string expression \"1\" , which evaluates to the integer value. The following keywords can/must be provided: Keyword Description Type Optional variables Collection of variables declaring data. list of Variable No variables The variables keyword is used to declare variables. Their scope and lifetime are bound to the associated scope defined by the persistentData , localData , or staticData keyword. Variable A variable declares data, it does so by providing an expression that, when evaluated, results in a data value. Whether a variable is in scope is dependent on how it is declared, see dynamic extent . new Variable { name = \"variableName\" value = \"1\" } Listing 2: A Variable construct. The following keywords can/must be provided: Keyword Description Type Optional name Name of the variable. string No value Value expression. Expression No name The name keyword specifies the name of the variable. It serves to reference the variable. Within a scope, the name of a variable must be unique. The validity of a variable name is implementation-specific. value The value keyword specifies the value expression of the variable. When evaluated, the value expression yields the variable's value. Evaluation of a value expression is implementation-specific. VariableReference A variable may be referenced through a variable reference. new VariableReference { reference = \"photoPath\" } Listing 3: A VariableReference construct. The following keywords can/must be provided: Keyword Description Type Optional reference Name of the referenced variable. Variable.name No reference The reference keyword specifies the name of the variable that is referenced. The variable reference must be an existing variable in scope. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"Data"},{"location":"csm-specifications/data/#data","text":"A Data construct is used to lexically declare data within a certain scope (see dynamic extent ), data may be persistent , local , or static . Persistent data is available persistently throughout and possibly outside the collaborative state machine. Local data is restricted to a subset of components of the collaborative state machine. Static data is specific to states. new Data { variables { new Variable {...}... } } Listing 1: A Data construct (we use ... to denote a placeholder for construct keywords, or multiple instances of a construct). The value of a variable is defined through an expression. In Listing 1, the integer value 1 is obtained from the string expression \"1\" , which evaluates to the integer value. The following keywords can/must be provided: Keyword Description Type Optional variables Collection of variables declaring data. list of Variable No","title":"Data"},{"location":"csm-specifications/data/#variables","text":"The variables keyword is used to declare variables. Their scope and lifetime are bound to the associated scope defined by the persistentData , localData , or staticData keyword.","title":"variables"},{"location":"csm-specifications/data/#variable","text":"A variable declares data, it does so by providing an expression that, when evaluated, results in a data value. Whether a variable is in scope is dependent on how it is declared, see dynamic extent . new Variable { name = \"variableName\" value = \"1\" } Listing 2: A Variable construct. The following keywords can/must be provided: Keyword Description Type Optional name Name of the variable. string No value Value expression. Expression No","title":"Variable"},{"location":"csm-specifications/data/#name","text":"The name keyword specifies the name of the variable. It serves to reference the variable. Within a scope, the name of a variable must be unique. The validity of a variable name is implementation-specific.","title":"name"},{"location":"csm-specifications/data/#value","text":"The value keyword specifies the value expression of the variable. When evaluated, the value expression yields the variable's value. Evaluation of a value expression is implementation-specific.","title":"value"},{"location":"csm-specifications/data/#variablereference","text":"A variable may be referenced through a variable reference. new VariableReference { reference = \"photoPath\" } Listing 3: A VariableReference construct. The following keywords can/must be provided: Keyword Description Type Optional reference Name of the referenced variable. Variable.name No","title":"VariableReference"},{"location":"csm-specifications/data/#reference","text":"The reference keyword specifies the name of the variable that is referenced. The variable reference must be an existing variable in scope. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"reference"},{"location":"csm-specifications/event/","text":"Event-related constructs are described below. Event Events are raised and handled by state machines in the collaborative state machine and are matched based on their name. Events fall into three categories: internal , external , and global . Internal events are exclusively handled by the state machine that raised them and not seen by other state machines. External events are received by state machines that have subscribed to the events raised by other state machines. This linkage introduces decentralization, allowing state machines to dynamically subscribe to events of interest raised by other state machines. Global events are not tied to any specific source state machine and are universally seen by every state machine. This universal handling establishes a global communication channel within the application. A raised event may contain data transmitted to the receiver; an expression is used to gather the data to include with the event. When a state machine processes the received event and takes a transition, the event data is assigned to the current state's local data using the name and value of each provided context variable. This overrides existing variables or creates new variables if they don't exist within the dynamic extent. new Event { name = \"e1\" channel = \"global\" data = new Data{...} } Listing 9: An Event construct. The following keywords can/must be provided: Keyword Description Type Optional name Event name. string No channel Event channel. channel No data Event data. list of Variable Yes name The name keyword specifies the event name. Events are matched according to their name. Event names may be re-used. The validity of the event name is implementation-specific. channel The channel keyword specifies the event channel of the raised event. The event channel is a string enumeration and must be one of the following: internal external global data The data keyword specifies the event data contained within the event. Event data will be assigned to the local data of the state machine's current state which processes the event and takes a transition. Event data can be accessed inside expressions by their variable names, with event data variables prefixed by a $ to indicate their special status compared to context variables. The lifetime of event data is bound to the transition following the event and any subsequently executed actions.","title":"Event"},{"location":"csm-specifications/event/#event","text":"Events are raised and handled by state machines in the collaborative state machine and are matched based on their name. Events fall into three categories: internal , external , and global . Internal events are exclusively handled by the state machine that raised them and not seen by other state machines. External events are received by state machines that have subscribed to the events raised by other state machines. This linkage introduces decentralization, allowing state machines to dynamically subscribe to events of interest raised by other state machines. Global events are not tied to any specific source state machine and are universally seen by every state machine. This universal handling establishes a global communication channel within the application. A raised event may contain data transmitted to the receiver; an expression is used to gather the data to include with the event. When a state machine processes the received event and takes a transition, the event data is assigned to the current state's local data using the name and value of each provided context variable. This overrides existing variables or creates new variables if they don't exist within the dynamic extent. new Event { name = \"e1\" channel = \"global\" data = new Data{...} } Listing 9: An Event construct. The following keywords can/must be provided: Keyword Description Type Optional name Event name. string No channel Event channel. channel No data Event data. list of Variable Yes","title":"Event"},{"location":"csm-specifications/event/#name","text":"The name keyword specifies the event name. Events are matched according to their name. Event names may be re-used. The validity of the event name is implementation-specific.","title":"name"},{"location":"csm-specifications/event/#channel","text":"The channel keyword specifies the event channel of the raised event. The event channel is a string enumeration and must be one of the following: internal external global","title":"channel"},{"location":"csm-specifications/event/#data","text":"The data keyword specifies the event data contained within the event. Event data will be assigned to the local data of the state machine's current state which processes the event and takes a transition. Event data can be accessed inside expressions by their variable names, with event data variables prefixed by a $ to indicate their special status compared to context variables. The lifetime of event data is bound to the transition following the event and any subsequently executed actions.","title":"data"},{"location":"csm-specifications/execution-model/","text":"This section defines the CSM execution model. The execution model is defined as the execution of an individual state machine. A collaborative state machine containing multiple (nested) state machines will concurrently execute each individual state machine according to the execution model. A state machine instance is associated with a status $\\mu = \\langle c^+, \\Gamma, \\Theta \\rangle$ that captures its current situation, including its dynamic extent $c^+$, input events $\\Gamma$, and active configuration $\\Theta$. The active configuration $\\Theta$ of the state machine is the set of states $s \\in S$ that are currently active . The CSM step algorithm aims to produce a new status according to changes in the state machine's environment that the state machine responds to. The step algorithm reaches a new status by performing a step . We say that a step consists of an arbitrary number of micro-steps and that a step is completed yielding a new status whenever no micro-step exists for the executed step. The CSM execution model adheres to the following principles: Changes that occur during a step are effective immediately. An event is available during one step only and becomes unavailable upon completion of the step where it is handled. A state machine is considered alive if the active configuration contains no terminal state. The execution of a step and a micro-step may take time. Actions defined are executed sequentially; a successive action is executed when the preceding action is completed. One state must be active in the active configuration. Principle 1 serves to ensure that changes to the state machine's status take effect immediately, avoiding non-determinism by committing changes without delay, thus maintaining consistency and predictability in the state machine's behavior. Principle 2 serves to prevent redundant processing of events within a single step, ensuring that each event is handled exactly once. By making events unavailable after processing in a step, this principle maintains the integrity of event-driven behavior and avoids potential inconsistencies. Principle 3 serves to define the lifetime of a state machine based on the absence of terminal states in its active configuration. By considering a state machine alive if it has states to transition through, this principle ensures that execution continues until a terminal state is reached, maintaining the ongoing functionality of the state machine. Principle 4 serves to acknowledge the potential time consumption during the execution of steps and micro-steps. By recognizing that execution may take time, this principle allows for accommodating delays caused by various factors, ensuring that the execution model remains robust and capable of handling real-world scenarios where computational or external dependencies may affect execution time. Principle 5 serves to enforce the sequential execution of actions defined within the state machine. By ensuring that each action is executed only after the completion of the preceding action, this principle maintains determinism and prevents race conditions or inconsistencies that could arise from concurrent execution of actions, thereby preserving the integrity of state transitions and overall system behavior. Principle 6 serves to avoid non-determinism, i.e., $|{s \\in \\theta \u2223 s \\text{ is active}}|=1$, by enforcing that only one state can be active in the active configuration at any given time. By ensuring that the active configuration always contains exactly one active state, this principle prevents ambiguity in state transitions and guarantees predictable behavior within the state machine. Step Algorithm We define the step algorithm as follows. procedure ExecuteStep Input Given the status $\\mu$ of a state machine. Ouput Provide a new status $\\mu$ of the state machine. $\\textbf{while } \\Theta \\neq \\emptyset \\textbf{ do}$ $x \\leftarrow \\text{Pop(}\\Theta\\text{)}$ $\\text{Handle(}x, \\mu\\text{)}$ Here, 1.1 ensures that events in the event queue are removed before handling, and 1.2 ensures that the status is updated according to the behavior that follows from events in the event queue. Before executing a single step, $\\Theta$ is updated with respect to any input events in the environment or collaborative state machine. External events, provided by the environment, are added to $\\Theta$ before the execution of a step. Timeout events are treated as external events. We define the Handle procedure as follows. procedure Handle Input Given an input event $x$ and status $\\mu$. Output Provide an updated status $\\mu$ according to the event. Select the active on transition $t$, given $x$ and $\\mu$, or $\\emptyset$ in case no active on transition exists. $\\textbf{while } \\delta \\neq \\emptyset \\textbf{ do}$ If $\\delta$ is an external transition. Cancel any while actions of the states exited due to $\\delta$. Execute the exit actions of the states exited due to $\\delta$. Execute the actions of $\\delta$. Execute the entry actions of the states entered due to $\\delta$. Execute the while actions of the states entered due to $\\delta$. Update the activate configuration. Set $\\delta$ the active always transition or $\\emptyset$ in case no active always transition exists. Otherwise. Execute the actions of $\\delta$. An on transition is selected (active) iff its source state (the state from which the transition starts) is the active state, its guard conditions evaluates to true, and $x$ is the event that would trigger the transition. An always transition is selected iff its source state (the state from which the transition starts) is the active state and its guard condition evaluates to true. The selection of a transition must yield exactly one transition. Conflicts arise whenever one event dictates that the state machine should make two atomic states active. This is invalid and will result in non-determinism. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"Execution Model"},{"location":"csm-specifications/execution-model/#step-algorithm","text":"We define the step algorithm as follows. procedure ExecuteStep Input Given the status $\\mu$ of a state machine. Ouput Provide a new status $\\mu$ of the state machine. $\\textbf{while } \\Theta \\neq \\emptyset \\textbf{ do}$ $x \\leftarrow \\text{Pop(}\\Theta\\text{)}$ $\\text{Handle(}x, \\mu\\text{)}$ Here, 1.1 ensures that events in the event queue are removed before handling, and 1.2 ensures that the status is updated according to the behavior that follows from events in the event queue. Before executing a single step, $\\Theta$ is updated with respect to any input events in the environment or collaborative state machine. External events, provided by the environment, are added to $\\Theta$ before the execution of a step. Timeout events are treated as external events. We define the Handle procedure as follows. procedure Handle Input Given an input event $x$ and status $\\mu$. Output Provide an updated status $\\mu$ according to the event. Select the active on transition $t$, given $x$ and $\\mu$, or $\\emptyset$ in case no active on transition exists. $\\textbf{while } \\delta \\neq \\emptyset \\textbf{ do}$ If $\\delta$ is an external transition. Cancel any while actions of the states exited due to $\\delta$. Execute the exit actions of the states exited due to $\\delta$. Execute the actions of $\\delta$. Execute the entry actions of the states entered due to $\\delta$. Execute the while actions of the states entered due to $\\delta$. Update the activate configuration. Set $\\delta$ the active always transition or $\\emptyset$ in case no active always transition exists. Otherwise. Execute the actions of $\\delta$. An on transition is selected (active) iff its source state (the state from which the transition starts) is the active state, its guard conditions evaluates to true, and $x$ is the event that would trigger the transition. An always transition is selected iff its source state (the state from which the transition starts) is the active state and its guard condition evaluates to true. The selection of a transition must yield exactly one transition. Conflicts arise whenever one event dictates that the state machine should make two atomic states active. This is invalid and will result in non-determinism. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"Step Algorithm"},{"location":"csm-specifications/expression/","text":"Expression-related constructs are described below. Expression An expression represents an evaluable one-line expression that serves to produce an output value. Expressions are used throughout CSML to represent boolean expressions as well as data expressions. Depending on the expression language supported by the runtime system implementation, additional functionality may be available, such as the execution of functions, boolean logic, or arithmetic. An expression is a string that is evaluated to acquire a certain value. \"5+5+v\" Listing 4: An Expression construct. The evaluation of an expression, e.g., the supported syntax, is implementation-specific. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"Expression"},{"location":"csm-specifications/expression/#expression","text":"An expression represents an evaluable one-line expression that serves to produce an output value. Expressions are used throughout CSML to represent boolean expressions as well as data expressions. Depending on the expression language supported by the runtime system implementation, additional functionality may be available, such as the execution of functions, boolean logic, or arithmetic. An expression is a string that is evaluated to acquire a certain value. \"5+5+v\" Listing 4: An Expression construct. The evaluation of an expression, e.g., the supported syntax, is implementation-specific. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"Expression"},{"location":"csm-specifications/guard/","text":"Guard-related constructs are described below. Guard A guard is an expression that evaluates to a boolean value. Guards are used within transitions to determine whether a transition is taken. new Guard { expression = \"v==5\" } Listing 5: A Guard construct. The following keywords can/must be provided: Keyword Description Type Optional expression The guard expression. Expression No expression The expression keyword specifies the guard expression. The guard expression must evaluate to a boolean value. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"Guard"},{"location":"csm-specifications/guard/#guard","text":"A guard is an expression that evaluates to a boolean value. Guards are used within transitions to determine whether a transition is taken. new Guard { expression = \"v==5\" } Listing 5: A Guard construct. The following keywords can/must be provided: Keyword Description Type Optional expression The guard expression. Expression No","title":"Guard"},{"location":"csm-specifications/guard/#expression","text":"The expression keyword specifies the guard expression. The guard expression must evaluate to a boolean value. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"expression"},{"location":"csm-specifications/specifications/","text":"Version 3.0 These are the Collaborative State Machine language specifications. These specifications describe the CSM Language (CSML), its syntax, semantics, and execution model. They define how state machines are constructed, how they interact in a collaborative environment, and the rules governing state transitions, events, and inter-state machine communication. Additionally, these specifications provide guidance for implementing CSML-compliant interpreters, compilers, and runtime environments, ensuring consistent behavior across different platforms and use cases. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"Specifications"},{"location":"csm-specifications/state-machine/","text":"State machine-related constructs are described below. StateMachine The purpose of a state machine is to model event-driven execution behavior across the computing continuum by enabling transitions between states or by accommodating nested state machines that are executed concurrently. Nested state machines allow a state machine to express concurrent behavior while providing mechanisms to observe and influence the execution of the parent state machine. They begin execution simultaneously with the parent state machine. A state machine consists of one or more states, which are reached through state transitions. At any given moment, only one state within a state machine is active, while all other states remain inactive. As with collaborative state machines, local and persistent data can be declared within a state machine. new StateMachine { name = \"SM2\" states { new State {...}... } stateMachines { new StateMachine {...}... } localData = new Data {...} persistentData = new Data {...} } Listing 7: A StateMachine construct. The following keywords can/must be provided: Keyword Description Type Optional name Name of the state machine. string No states Collection of states. list of State No stateMachines Collection of state machines. list of StateMachine No localData Local data. Data Yes persistentData Persistent data. Data Yes name The name keyword specifies the name of the state machine and may be used for diagnostic purposes or referencing. The name of a state machine is not referenced inside a description. The validity of a name is implementation-specific. states The states keyword is used to specify the collection of atomic states included in the state machine. Atomic states are described using the State construct. At least one state must be declared. State.name s must be unique. Exactly one initial state must be declared. Initial states must not have inward transitions. Terminal states must not have outward transitions. Every state must be reachable (it must have a transition leading into it, or it must be the initial state). stateMachines The stateMachines keyword is used to specify the collection of nested state machines. Nested state machines are described using the StateMachine construct. localData / persistentData The localData and persistentData keywords allow for lexically declaring respectively the local and persistent data at the state machine level. Data described at the state machine level is accessible from the state machine and any component hierarchically below it, see dynamic extent .","title":"State Machine"},{"location":"csm-specifications/state-machine/#statemachine","text":"The purpose of a state machine is to model event-driven execution behavior across the computing continuum by enabling transitions between states or by accommodating nested state machines that are executed concurrently. Nested state machines allow a state machine to express concurrent behavior while providing mechanisms to observe and influence the execution of the parent state machine. They begin execution simultaneously with the parent state machine. A state machine consists of one or more states, which are reached through state transitions. At any given moment, only one state within a state machine is active, while all other states remain inactive. As with collaborative state machines, local and persistent data can be declared within a state machine. new StateMachine { name = \"SM2\" states { new State {...}... } stateMachines { new StateMachine {...}... } localData = new Data {...} persistentData = new Data {...} } Listing 7: A StateMachine construct. The following keywords can/must be provided: Keyword Description Type Optional name Name of the state machine. string No states Collection of states. list of State No stateMachines Collection of state machines. list of StateMachine No localData Local data. Data Yes persistentData Persistent data. Data Yes","title":"StateMachine"},{"location":"csm-specifications/state-machine/#name","text":"The name keyword specifies the name of the state machine and may be used for diagnostic purposes or referencing. The name of a state machine is not referenced inside a description. The validity of a name is implementation-specific.","title":"name"},{"location":"csm-specifications/state-machine/#states","text":"The states keyword is used to specify the collection of atomic states included in the state machine. Atomic states are described using the State construct. At least one state must be declared. State.name s must be unique. Exactly one initial state must be declared. Initial states must not have inward transitions. Terminal states must not have outward transitions. Every state must be reachable (it must have a transition leading into it, or it must be the initial state).","title":"states"},{"location":"csm-specifications/state-machine/#statemachines","text":"The stateMachines keyword is used to specify the collection of nested state machines. Nested state machines are described using the StateMachine construct.","title":"stateMachines"},{"location":"csm-specifications/state-machine/#localdata-persistentdata","text":"The localData and persistentData keywords allow for lexically declaring respectively the local and persistent data at the state machine level. Data described at the state machine level is accessible from the state machine and any component hierarchically below it, see dynamic extent .","title":"localData / persistentData"},{"location":"csm-specifications/state/","text":"State-related constructs are described below. State A state represents a potentially active state, which can be activated by entering through a state transition and can be initial , terminal , or neither (intermediate). There must be exactly one initial state within a state machine. A terminal state, of which multiple can exist, indicates the end of the lifecycle of the containing state machine. State transitions are specified as always or on transitions. Always transitions, possibly guarded with expressions, are taken without events. On-event transitions drive the event-driven nature of state machines, allowing a state transition based on a received event. Events may be generated from the state machine itself, other state machines, as well as from the environment external to CSM (for instance, an external application or device). Actions executed in a state include entry and exit actions upon entering or exiting the state. While actions are executed while the state is active. Timed actions are declared using the after keyword. Like other constructs, a state allows for lexically declaring local, static, and persistent data. An additional type of data, static data, utilizes the capability of the state for re-entry, allowing data to retain their values between exiting and re-entering the state. new State { name = \"Sa\" initial = true terminal = false entry { new Action {...}... } exit { new Action {...}... } while { new Action {...}... } after { new Action {...}... } on { new OnTransition {...}... } always { new Transition{ ... }... } localData = new Data {...} persistentData = new Data {...} staticData = new Data {...} } Listing 8: A State construct. The following keywords can/must be provided: Keyword Description Type Optional name Name of the state. string No initial Initial flag of the state. boolean Yes terminal Terminal flag of the state. boolean Yes entry Entry actions. list of Action Yes exit Exit actions. list of Action Yes while While actions. list of Action Yes after After actions. list of TimeoutAction Yes on On event transitions. list of OnTransition Yes always Always transitions. list of Transition Yes localData Local data. Data Yes persistentData Persistent data. Data Yes staticData Static data. Data Yes name The name keyword specifies the name of the state and may be used for diagnostic purposes or referencing. A state's name is referenced throughout the state machine to indicate the transition target. The validity of a name is implementation-specific. initial The initial keyword specifies whether a state is the initial state of the containing state machine. Exactly one initial state must be declared. Initial states must not have inward transitions. terminal The terminal keyword specifies whether a state is a terminal state of the containing state machine. Multiple states may be declared terminal. Terminal states must not have outward transitions. entry / exit / while / after The entry keyword specifies the actions executed upon entry of the state. The exit keyword specifies the actions executed upon exiting the state. The while keyword specifies the actions executed while in a state. The after keyword specifies the actions executed upon a timeout. Actions executed within a state have state scope, see dynamic extent . An action reference must be a valid action name. on The on keyword specifies the transitions that can occur based on events. The referenced event in an on-transition must be raised within the collaborative state machine. always The always keyword specifies the transitions that can occur regardless of raised events. localData / persistentData / staticData The localData , persistentData , and staticData keywords allow for lexically declaring respectively the local, persistent, and static data at the state machine level. Static data is unique to states and is available after re-entry of a state. Data described at the state level is accessible from the state machine and any component hierarchically below it, see dynamic extent .","title":"State"},{"location":"csm-specifications/state/#state","text":"A state represents a potentially active state, which can be activated by entering through a state transition and can be initial , terminal , or neither (intermediate). There must be exactly one initial state within a state machine. A terminal state, of which multiple can exist, indicates the end of the lifecycle of the containing state machine. State transitions are specified as always or on transitions. Always transitions, possibly guarded with expressions, are taken without events. On-event transitions drive the event-driven nature of state machines, allowing a state transition based on a received event. Events may be generated from the state machine itself, other state machines, as well as from the environment external to CSM (for instance, an external application or device). Actions executed in a state include entry and exit actions upon entering or exiting the state. While actions are executed while the state is active. Timed actions are declared using the after keyword. Like other constructs, a state allows for lexically declaring local, static, and persistent data. An additional type of data, static data, utilizes the capability of the state for re-entry, allowing data to retain their values between exiting and re-entering the state. new State { name = \"Sa\" initial = true terminal = false entry { new Action {...}... } exit { new Action {...}... } while { new Action {...}... } after { new Action {...}... } on { new OnTransition {...}... } always { new Transition{ ... }... } localData = new Data {...} persistentData = new Data {...} staticData = new Data {...} } Listing 8: A State construct. The following keywords can/must be provided: Keyword Description Type Optional name Name of the state. string No initial Initial flag of the state. boolean Yes terminal Terminal flag of the state. boolean Yes entry Entry actions. list of Action Yes exit Exit actions. list of Action Yes while While actions. list of Action Yes after After actions. list of TimeoutAction Yes on On event transitions. list of OnTransition Yes always Always transitions. list of Transition Yes localData Local data. Data Yes persistentData Persistent data. Data Yes staticData Static data. Data Yes","title":"State"},{"location":"csm-specifications/state/#name","text":"The name keyword specifies the name of the state and may be used for diagnostic purposes or referencing. A state's name is referenced throughout the state machine to indicate the transition target. The validity of a name is implementation-specific.","title":"name"},{"location":"csm-specifications/state/#initial","text":"The initial keyword specifies whether a state is the initial state of the containing state machine. Exactly one initial state must be declared. Initial states must not have inward transitions.","title":"initial"},{"location":"csm-specifications/state/#terminal","text":"The terminal keyword specifies whether a state is a terminal state of the containing state machine. Multiple states may be declared terminal. Terminal states must not have outward transitions.","title":"terminal"},{"location":"csm-specifications/state/#entry-exit-while-after","text":"The entry keyword specifies the actions executed upon entry of the state. The exit keyword specifies the actions executed upon exiting the state. The while keyword specifies the actions executed while in a state. The after keyword specifies the actions executed upon a timeout. Actions executed within a state have state scope, see dynamic extent . An action reference must be a valid action name.","title":"entry / exit / while / after"},{"location":"csm-specifications/state/#on","text":"The on keyword specifies the transitions that can occur based on events. The referenced event in an on-transition must be raised within the collaborative state machine.","title":"on"},{"location":"csm-specifications/state/#always","text":"The always keyword specifies the transitions that can occur regardless of raised events.","title":"always"},{"location":"csm-specifications/state/#localdata-persistentdata-staticdata","text":"The localData , persistentData , and staticData keywords allow for lexically declaring respectively the local, persistent, and static data at the state machine level. Static data is unique to states and is available after re-entry of a state. Data described at the state level is accessible from the state machine and any component hierarchically below it, see dynamic extent .","title":"localData / persistentData / staticData"},{"location":"csm-specifications/transition/","text":"Transition-related constructs are described below. Transition A state transition enables the transitioning between the states of a state machine. The result of a state transition is exiting the currently active state and entering the newly active state. CSML supports external transitions, using the target keyword to specify a target state towards which the transition is directed within the same state machine. A state may externally transition into itself by declaring a transition with its state name. Optionally, the target state may be omitted, leading to an internal transition. In this case, the state machine stays in its current state, bypassing the execution of any actions triggered by entering or exiting a state while still carrying out the transition actions. Guard conditions are provided as expressions in the context of transitions. A guard expression $E : \\mathbb{R}^n \\to {\\text{true}, \\text{false}}$ takes the form where $\\mathbb{R}^n$ represents the domain, consisting of all variables in scope, see dynamic extent . To initiate a transition, the conjunction of all guard expressions must collectively evaluate to true. The actions keyword is used to specify the actions executed when the transition is taken. new Transition { target = \"Sa\" guards { new Guard {...}... } actions { new Action {...}... } else = \"Sb\" } Listing 10: A Transition construct. Transition guards must be mutually exclusive to ensure determinism, so that at most one transition can be triggered from any given state at a time. The following keywords can/must be provided: Keyword Description Type Optional target Target state name. State.name No guards Guard conditions. list of Guard Yes actions Transition actions. list of Action Yes else Else target. State.name Yes OnTransition The on-transition construct is a specialization of the transition construct, adding the event keyword that specifies the event that triggers the transition. new OnTransition { event = \"e1\" target = \"Sa\" guards { new Guard {...}... } actions { new Action {...}... } else = \"Sb\" } Listing 11: An OnTransition construct. The following keywords can/must be provided: Keyword Description Type Optional event Event responding to. string No target The target keyword specifies the State.name to transition into. The target state name must be valid. guards The guards keyword specifies the guard conditions of the transition. All guard expressions must evaluate to boolean true for the transition to be taken. The guard expression must evaluate to boolean true or false. actions The actions keyword specifies the actions executed as part of the transition. Actions may be declared in-line, in which case an action name is not required. Actions may also be referenced by name. Actions executed within a state have state-scope, see dynamic extent . An action reference must be a valid action name. else The else keyword specifies the state to transition into, should the guard condition not evaluate to boolean true. The else state name must be valid. event The event keyword specifies the name of an event that triggers the on-transition. The name of the event must be an event raised within the collaborative state machine. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"Transition"},{"location":"csm-specifications/transition/#transition","text":"A state transition enables the transitioning between the states of a state machine. The result of a state transition is exiting the currently active state and entering the newly active state. CSML supports external transitions, using the target keyword to specify a target state towards which the transition is directed within the same state machine. A state may externally transition into itself by declaring a transition with its state name. Optionally, the target state may be omitted, leading to an internal transition. In this case, the state machine stays in its current state, bypassing the execution of any actions triggered by entering or exiting a state while still carrying out the transition actions. Guard conditions are provided as expressions in the context of transitions. A guard expression $E : \\mathbb{R}^n \\to {\\text{true}, \\text{false}}$ takes the form where $\\mathbb{R}^n$ represents the domain, consisting of all variables in scope, see dynamic extent . To initiate a transition, the conjunction of all guard expressions must collectively evaluate to true. The actions keyword is used to specify the actions executed when the transition is taken. new Transition { target = \"Sa\" guards { new Guard {...}... } actions { new Action {...}... } else = \"Sb\" } Listing 10: A Transition construct. Transition guards must be mutually exclusive to ensure determinism, so that at most one transition can be triggered from any given state at a time. The following keywords can/must be provided: Keyword Description Type Optional target Target state name. State.name No guards Guard conditions. list of Guard Yes actions Transition actions. list of Action Yes else Else target. State.name Yes","title":"Transition"},{"location":"csm-specifications/transition/#ontransition","text":"The on-transition construct is a specialization of the transition construct, adding the event keyword that specifies the event that triggers the transition. new OnTransition { event = \"e1\" target = \"Sa\" guards { new Guard {...}... } actions { new Action {...}... } else = \"Sb\" } Listing 11: An OnTransition construct. The following keywords can/must be provided: Keyword Description Type Optional event Event responding to. string No","title":"OnTransition"},{"location":"csm-specifications/transition/#target","text":"The target keyword specifies the State.name to transition into. The target state name must be valid.","title":"target"},{"location":"csm-specifications/transition/#guards","text":"The guards keyword specifies the guard conditions of the transition. All guard expressions must evaluate to boolean true for the transition to be taken. The guard expression must evaluate to boolean true or false.","title":"guards"},{"location":"csm-specifications/transition/#actions","text":"The actions keyword specifies the actions executed as part of the transition. Actions may be declared in-line, in which case an action name is not required. Actions may also be referenced by name. Actions executed within a state have state-scope, see dynamic extent . An action reference must be a valid action name.","title":"actions"},{"location":"csm-specifications/transition/#else","text":"The else keyword specifies the state to transition into, should the guard condition not evaluate to boolean true. The else state name must be valid.","title":"else"},{"location":"csm-specifications/transition/#event","text":"The event keyword specifies the name of an event that triggers the on-transition. The name of the event must be an event raised within the collaborative state machine. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: \"none\" });","title":"event"},{"location":"research/publications/","text":"The following publications cover research on Collaborative State Machines. 2025 Marlon Etheredge, Thomas Fahringer, Felix Erlacher, Elias Kohler, Stefan Pedratscher, Juan Aznar-Poveda, Nishant Saurabh, and Adrien Lebre. Collaborative State Machines: A Better Programming Model for the Cloud-Edge-IoT Continuum. July 2025. arXiv:2507.21685 , doi:10.48550/arXiv.2507.21685 . Juan Aznar Poveda, Marlon Etheredge, Stefan Pedratscher, Patrick K\u00fcnig, and Thomas Fahringer. Nyx: A Fault-Tolerant Fully Distributed Message Queue for the IoT-Edge-Cloud Continuum. In 2025 21st International Conference on Distributed Computing in Smart Systems and the Internet of Things (DCOSS-IoT) , 1021\u20131026. June 2025. doi:10.1109/DCOSS-IoT65416.2025.00154 .","title":"Publications"},{"location":"research/team/","text":"Collaborative State Machines originated within the Distributed and Parallel Systems Group at the University of Innsbruck and continue to be developed there. The following list presents the current team members actively working on Collaborative State Machines. Marlon Etheredge, MSc Monik Raj Behera, MSc Dr. Juan Aznar Poveda Univ.-Prof. Dr. Thomas Fahringer Alumni The following list shows anonymized alumni and their research topics. BSc, 2024 \u2014 Thesis on distributed event queues BSc, 2024 \u2014 Thesis on resource management BSc, 2024 \u2014 Thesis on visual modeling for Cloud-Edge-IoT MSc, 2024 \u2014 Innovative extensions of the Collaborative State Machines model and formalization. BSc, 2023 \u2014 Thesis on a Collaborative State Machines implementation.","title":"Team"},{"location":"research/team/#alumni","text":"The following list shows anonymized alumni and their research topics. BSc, 2024 \u2014 Thesis on distributed event queues BSc, 2024 \u2014 Thesis on resource management BSc, 2024 \u2014 Thesis on visual modeling for Cloud-Edge-IoT MSc, 2024 \u2014 Innovative extensions of the Collaborative State Machines model and formalization. BSc, 2023 \u2014 Thesis on a Collaborative State Machines implementation.","title":"Alumni"}]}