{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Collaborative State Machines","text":"<p>Collaborative State Machines (CSM) is a programming model for building reactive, distributed applications \ud83c\udf10 that run seamlessly across the cloud, edge, and IoT.</p> <p>Modern applications are increasingly dynamic, stateful, and distributed across multiple environments, which traditional programming models often struggle to handle. CSM addresses this challenge by letting you design applications as collections of autonomous state machines that collaborate \ud83e\udd1d. Each machine can run in the cloud, at the edge, or directly on IoT devices, while the system continues to operate as a single cohesive application.</p>"},{"location":"#about-us","title":"About us","text":"<p>CSM is a research project developed by the Distributed and Parallel Systems Group \ud83c\udfdb\ufe0f at the University of Innsbruck.</p> <p>As a research initiative, CSM aims to create a disruptive, reactive programming model \u26a1 for distributed applications that span the cloud, edge, and IoT. Our goal is to enable developers to build systems that are responsive, stateful, and scalable, while remaining simple to reason about and deploy in real-world environments.</p> <p>The project explores how collections of collaborating state machines can provide a cohesive, event-driven view of a distributed application, supporting automatic scheduling, deployment, and optimization across heterogeneous computing layers.</p> <p>By combining theory with practical experimentation, CSM seeks to bridge the gap between academic research \ud83d\udcda and real-world distributed systems \u2699\ufe0f, providing a model that is both rigorous and applicable.</p> <p>Research</p> <p>Explore our Research and meet the Team to learn more about the people behind CSM.</p>"},{"location":"#state-machines","title":"State machines","text":"<p>At the heart of CSM are small, autonomous state machines \ud83d\udd39 that form the building blocks of distributed applications. Each state machine maintains its own state, responds to events, and can trigger actions or external services. When combined, these machines create a cohesive, reactive system capable of operating across cloud, edge, and IoT environments without being tied to specific hardware or infrastructure.</p> <p>State machines in CSM are designed to:</p> <ul> <li> <p>React to events \u26a1 from sensors, other machines, or the surrounding environment, enabling timely and   context-aware responses.</p> </li> <li> <p>Maintain their own state \ud83d\uddc2\ufe0f while optionally interacting with persistent or shared data, providing   consistency and traceability.</p> </li> <li> <p>Trigger actions or services \ud83d\udee0\ufe0f directly within states and transitions, allowing state-driven execution   of business logic or external operations.</p> </li> <li> <p>Collaborate seamlessly \ud83e\udd1d by exchanging events and data with other machines, supporting coordinated   behavior across distributed components.</p> </li> </ul> <p>This approach makes it easier to reason about complex, distributed, event-driven logic, ensuring that applications remain predictable, maintainable, and scalable while leveraging the full power of reactive programming.</p> <p>Learn</p> <p>Learn more about the fundamental programming model in the CSM Specifications.</p>"},{"location":"#features","title":"Features","text":"<p>CSM provides a set of core capabilities that make building distributed, event-driven applications more structured and manageable:</p> <ul> <li> <p>Resilience \ud83c\udf31 \u2014 applications adapt dynamically to changing conditions and can recover gracefully from   partial failures, ensuring robust operation across heterogeneous environments.</p> </li> <li> <p>Modularity \ud83e\udde9 \u2014 each state machine encapsulates a distinct piece of behavior, simplifying   understanding, maintenance, and extension of the overall system.</p> </li> <li> <p>True distribution \ud83c\udf0d \u2014 state machines can run seamlessly across cloud, edge, and IoT devices without   requiring manual handling of communication, coordination, or deployment details.</p> </li> <li> <p>Separation of concerns \u2696\ufe0f \u2014 application logic is expressed independently of infrastructure, allowing   developers to focus on what the system should do rather than how it is deployed or executed.</p> </li> <li> <p>Structured data management \ud83d\udce6 \u2014 local, transient, and persistent data are handled with well-defined   scopes and lifecycles, supporting consistency and observability throughout the application.</p> </li> </ul> <p>This combination of features ensures that applications built with CSM are scalable, maintainable, and predictable, while taking full advantage of distributed execution environments.</p> <p>Learn</p> <p>Get started quickly by following our getting started guide.</p>"},{"location":"#use-cases","title":"Use cases","text":"<p>CSM is particularly well-suited for systems that are distributed, event-driven, and stateful. Its reactive and modular approach enables developers to design applications that respond efficiently to changes in their environment while maintaining consistent state across heterogeneous components. Common use cases include:</p> <ul> <li> <p>IoT &amp; Edge Solutions \ud83d\udce1 \u2014 devices react to local events with minimal latency while coordinating and   syncing with cloud services for analytics, logging, or further processing.</p> </li> <li> <p>Surveillance &amp; Monitoring \ud83c\udfa5 \u2014 distributed data streams are collected, processed, and acted upon in   real time, supporting automated alerts and operational insights.</p> </li> <li> <p>Smart Factories \ud83c\udfed \u2014 workflows orchestrate machines, sensors, and analytics pipelines to optimize   production, reduce downtime, and maintain safety.</p> </li> <li> <p>Large-Scale Cloud Systems \u2601\ufe0f \u2014 scalable applications with a clear separation of business logic and   infrastructure, supporting multiple distributed components without sacrificing maintainability or    observability.</p> </li> </ul> <p>This flexibility makes CSM a versatile programming model for any scenario requiring reliable, reactive, and coordinated distributed behavior.</p> <p>Learn</p> <p>Discover more in our Examples or follow the Tutorial to see CSM in action.</p>"},{"location":"csm-specifications/action/","title":"Action","text":""},{"location":"csm-specifications/action/#invokeaction","title":"InvokeAction","text":"<p>An invoke action allows a state machine to call a defined service type. The term 'type' in 'service type' refers to the CSM service abstraction. Invoking a service type does not specify a particular implementation. Instead, a service type may represent multiple variants of a service, which can differ in algorithm, resource optimization, or approximate computation methods to reduce costs. The runtime system selects the specific implementation based on available context, such as user or environmental information, to optimize for performance or other objectives.</p> <p>Input data for a service invocation can be provided through one or more expressions specified with the input keyword.</p> <p>To handle actions executed after the service completes, done events can be declared. These events provide access to the service's output data, which can be stored, passed to subsequent invocations or events, or used in other actions.</p> <p>Setting the local keyword to true signals the runtime system to invoke the service locally, on the same resource as the state machine, if possible. If omitted or set to false, the service may be invoked remotely on a different resource.</p> <p><pre><code>new InvokeAction {\n  serviceType = \"serviceTypeName\"\n  local = false\n  input = new Data {...}\n  output = new Data {...}\n  done {\n    new Event {...}...\n  }\n}\n</code></pre> Listing 11: An InvokeAction construct.</p> <p>The following keywords can/must be provided:</p> Keyword Description Type Optional type Type of action. string No serviceType Service type name. string No local Local execution flag. boolean Yes input Input data. list of ContextVariable Yes output Output data reference. list of ContextVariableReference Yes done Done events. list of Event Yes"},{"location":"csm-specifications/action/#servicetype","title":"serviceType","text":"<p>The serviceType keyword specifies the invoked service type.</p> <p>The service type is provided as a string value.</p> <p>Info</p> <p>The validity of the service type is implementation-specific.</p>"},{"location":"csm-specifications/action/#local","title":"local","text":"<p>The local keyword provides a hint to the runtime system implementation that the service type is intended to be invoked locally, in case of boolean true. Otherwise, it is not specified where the runtime system implementation should invoke the service type.</p>"},{"location":"csm-specifications/action/#input","title":"input","text":"<p>The input keyword specifies the input to the invoked service type.</p>"},{"location":"csm-specifications/action/#output","title":"output","text":"<p>The output keyword specifies context variables where the output of the invoked service type should be  stored. This is done by matching context variables received as output from the service invocation with the  output references defined using this keyword. Variable references can be local, static or persistent context variables.</p>"},{"location":"csm-specifications/action/#done","title":"done","text":"<p>The done keyword specifies the events raised after invocation. Raising done events allows for asynchronous service type invocation, allow transitioning into subsequent states whenever the service type invocation has been completed.</p>"},{"location":"csm-specifications/action/#createaction-assignaction-deleteaction","title":"CreateAction / AssignAction / DeleteAction","text":"<p>Data manipulation actions enable the dynamic creation of variables as local or persistent data, the assignment of values to existing variables, and the deletion of variables.</p> <p>When creating a variable, the persistent keyword is used to specify whether the variable should be created persistently. In case the keyword is omitted or has the value false, the variable is locally created in the current scope.</p> <p><pre><code>new CreateAction {\n  variable = new ContextVariable {...}\n  persistent = true\n}\n\nnew AssignAction {\n  variable = new ContextVariableReference {...}\n  value = new Expression {...}\n}\n\nnew DeleteAction {\n  variable = new ContextVariableReference {...}\n}\n</code></pre> Listing 12: A CreateAction, AssignAction, and DeleteAction construct.</p> <p>The following keywords can/must be provided (create action construct):</p> Keyword Description Type Optional variable Variable to create. ContextVariable No persistent Whether to create data persistently. boolean Yes <p>The following keywords can/must be provided (assign action construct):</p> Keyword Description Type Optional variable Variable reference to assign to. ContextVariableReference No value Value expression. Expression No <p>The following keywords can/must be provided (delete action construct):</p> Keyword Description Type Optional variable Variable reference to delete. ContextVariableReference No"},{"location":"csm-specifications/action/#variable","title":"variable","text":"<p>The variable keyword specifies the variable to create or the variable reference to manipulate.</p> <p>Rule</p> <p>When creating a variable, the variable must not exist.</p> <p>Rule</p> <p>When manipulating an existing variable, the variable must exist.</p>"},{"location":"csm-specifications/action/#persistent","title":"persistent","text":"<p>The persistent keyword specifies, for a create action, whether the variable needs to be created persistently. In case it must, the variable is created in the persistent data. Otherwise, the variable is locally created in the current scope.</p>"},{"location":"csm-specifications/action/#value","title":"value","text":"<p>The value keyword specifies the value expression for an assign action. The expression is evaluated to acquire the data value assigned to the variable.</p>"},{"location":"csm-specifications/action/#raiseaction","title":"RaiseAction","text":"<p><pre><code>new RaiseAction {\n  event = new Event { ... }\n}\n</code></pre> Listing 13: A raise event action construct.</p> <p>The raise event action enables a state machine to raise an event that is subsequently handled by another state machine or the state machine itself.</p> <p>The following keywords can/must be provided (raise action construct):</p> Keyword Description Type Optional event The event to raise. Event No"},{"location":"csm-specifications/action/#event","title":"event","text":"<p>The event specifies the event to raise within the collaborative state machine.</p>"},{"location":"csm-specifications/action/#matchaction","title":"MatchAction","text":"<p>Coming soon.</p>"},{"location":"csm-specifications/action/#timeoutaction-timeoutresetaction","title":"TimeoutAction / TimeoutResetAction","text":"<p><pre><code>new TimeoutAction {\n  name = \"timeout\"\n  delay = new Expression {...}\n  action = new RaiseAction {...}\n}\n\nnew TimeoutResetAction {\n  action = \"timeout\"\n}\n</code></pre> Listing 14: A timeout and timeout reset action construct.</p> <p>A special type of action, the timeout action, is used together with the after keyword. The timeout action specifies a delay, after which the specified action is executed. The provided action must be a raise event  action so subsequent behavior can be triggered upon a raised event.</p> <p>Timeouts can be reset based on the reset timeout action.</p> <p>The following keywords can/must be provided (timeout action construct):</p> Keyword Description Type Optional name The timeout action name. string No delay The event to raise. Expression No action The action to execute upon timeout. RaiseAction No <p>The following keywords can/must be provided (timeout reset action construct):</p> Keyword Description Type Optional action The timeout action to reset. TimeoutAction.name No"},{"location":"csm-specifications/action/#name","title":"name","text":"<p>The name keyword specifies the name of the timeout action used to reference the timeout action for  resetting.</p> <p>Info</p> <p>The validity of an action name is implementation-specific.</p>"},{"location":"csm-specifications/action/#delay","title":"delay","text":"<p>The delay keyword specifies the delay expression evaluated to provide the delay value. The delay value is specified in milliseconds.</p> <p>Rule</p> <p>The delay expression must be evaluated to a numeric value.</p>"},{"location":"csm-specifications/action/#action","title":"action","text":"<p>For a timeout action, the action keyword specifies the action to execute upon the timeout. The action  provided must be a raised event action.</p> <p>Rule</p> <p>The actions provided as timeout actions must be raise event actions.</p> <p>For a timeout reset action, the action keyword specifies the timeout action to reset. The action referenced must be a previously executed timeout action.</p> <p>Rule</p> <p>The action reference provided must be a previously executed timeout action.</p>"},{"location":"csm-specifications/background/","title":"Background","text":"<p>Collaborative State Machines is a distributed programming model for the computing continuum<sup>1</sup>. It represents distributed applications as state machines that can be deployed across resources throughout the  continuum. The model is designed for reactive, stateful, and highly dynamic applications that must operate in heterogeneous environments.</p> <p>While CSM defines the abstract programming model, its applications are expressed in the associated language, CSML. Like the model itself, CSML is abstract and can be realized in different ways, for example through  serialization formats or domain-specific languages. In these specifications, we describe CSML and the CSM  concepts using the Pkl-based implementation of CSML employed by the official runtime system, Cirrina.</p> <p>Within CSML a description consists of constructs, such as those describing a collaborative state machine,  state machine and state. A construct consists of one or multiple keywords.</p>"},{"location":"csm-specifications/background/#csm-description","title":"CSM description","text":"<p>Figure 1: An example of a CSM description. Components can have data represented by {...}.</p> <p>CSML is used to create CSM descriptions. A description represents the static structure of an application that is executable by a CSM runtime system.</p> <p>A CSM description takes the form of a tree structure. At its root is a collaborative state machine, encompassing one or more state machines. A state machine contains one or more states. These fundamental entities, collaborative state machine, state machines, and states, are called components. Every component can declare local and persistent (globally accessible) data.</p> <p>Figure 1 above illustrates a CSM tree structure. The presented collaborative state machine has two state machines, \\(SM_1\\) and \\(SM_2\\), along with a nested state machine denoted as \\(SM_{21}\\). Every state machine has two atomic states. The data variables of all components are represented by \\(a, \\ldots, h\\).</p> <ol> <li> <p>We refer to the computing continuum as the infrastructure spanning cloud, edge, and IoT layers.\u00a0\u21a9</p> </li> </ol>"},{"location":"csm-specifications/collaborative-state-machine/","title":"Collaborative state machine","text":""},{"location":"csm-specifications/collaborative-state-machine/#collaborativestatemachine","title":"CollaborativeStateMachine","text":"<p>Within CSM, state machines are inspired by David Harel's statecharts. Their primary role is to exhibit  autonomous, reactive behavior through state transitions. Actions can occur during transitions, upon entering  or exiting a state, or while residing in a state. These actions may include invoking computational services,  manipulating data, or raising events.</p> <p>A collaborative state machine extends beyond single state machines by modeling an application as a collection of one or more state machines distributed across the computing continuum. State machines collaborate by raising and handling events and by sharing data. CSM defines a data model that includes persistent, local, and static data. Local and persistent data are declared through variables. Data declared within a component description is lexically declared, meaning it is created as part of the description itself, rather than dynamically generated through actions (see data model). Variable values are determined by evaluating expressions.</p> <p>The memory mode defines how state machines may be distributed across the computing continuum. A collaborative state machine operates in one of two memory modes: shared or distributed. In shared memory mode, all state machines reside on the same computing resource and share memory. In distributed memory mode, state machines can execute on separate resources, each with private memory. These components run on a distributed computing infrastructure.</p> <p>Single state machines always operate in shared memory mode.</p> <p>Choosing between distributed and shared memory modes has significant implications. Distributed memory enables greater parallelism, scalability, replication, and decentralization, but may increase data transfer times when state machines on different resources need to exchange data.</p> <p>For more details, see the data model description.</p> <p><pre><code>new CollaborativeStateMachine {\n  name = \"CSM\"\n  version = \"3.0.0\"\n  memoryMode = \"distributed\"\n  stateMachines {\n    new StateMachine {...}...\n  }\n  localData = new Context {...}\n  persistentData = new Context {...}\n}\n</code></pre> Listing 6: A CollaborativeStateMachine construct.</p> <p>The following keywords can/must be provided:</p> Keyword Description Type Optional name Name of the collaborative state machine. string No version CSML version. version No memoryMode Memory mode. memoryMode No stateMachines Collection of state machines. list of StateMachine No localData Local data. Context Yes persistentData Persistent data. Context Yes"},{"location":"csm-specifications/collaborative-state-machine/#name","title":"name","text":"<p>The name keyword specifies the name of the collaborative state machine.</p> <p>The name of the collaborative state machine is not referenced within the collaborative state machine and only serves to identify the collaborative state machine among other collaborative state machines.</p> <p>Info</p> <p>The validity of a collaborative state machine name is implementation-specific.</p>"},{"location":"csm-specifications/collaborative-state-machine/#version","title":"version","text":"<p>The version keyword specifies the CSML version used within a description and is used to ensure backward-compatibility.</p> <p>The CSML version is bound to a version of these specifications. </p> <p>The version is a string enumeration and must be one of the following:</p> <ul> <li>3.0.0</li> </ul> <p>Info</p> <p>A runtime system implementation's support for different CSML versions is implementation-specific.</p>"},{"location":"csm-specifications/collaborative-state-machine/#memorymode","title":"memoryMode","text":"<p>The memoryMode keyword specifies the memory mode of the complete collaborative state machine.</p> <p>The memory mode applies to the entire collaborative state machine.</p> <p>The memory mode is a string enumeration and must be one of the following:</p> <ul> <li>distributed</li> <li>shared</li> </ul>"},{"location":"csm-specifications/collaborative-state-machine/#statemachines","title":"stateMachines","text":"<p>The stateMachines keyword is used to specify the collection of state machines included in the collaborative state machine.</p> <p>Rule</p> <p>At least one state machine must be declared.</p>"},{"location":"csm-specifications/collaborative-state-machine/#localdata-persistentdata","title":"localData / persistentData","text":"<p>The localData and persistentData keywords allow for lexically declaring respectively the local and persistent data of the collaborative state machine.</p> <p>Depending on the memory mode of the collaborative state machine, either or both types of data will be accessible within the collaborative state machine, see dynamic extent.</p>"},{"location":"csm-specifications/data-model/","title":"Data model","text":"<p>Figure 1 (repeated): An example of a CSM description. Components can have data represented by {...}.</p> <p>The scoping of local data within a collaborative state machine is defined with respect to the dynamic extent of the components of \\(C\\) with shared memory.</p> <p>We denote the dynamic extent of a component \\(c\\) as \\(c^+\\) to include the component itself and any ancestor of \\(c\\). When operating in shared memory mode, \\(C\\) is guaranteed to execute on a single resource with shared memory such that any component \\(c \\in C\\) can access local data according to \\(c^+\\) and \\(c_0^+\\) where \\(c_0\\),  the root level, denotes the collaborative state machine.</p> <p>The root of a collaborative state machine in distributed memory mode has no shared memory and thus cannot  declare or access local data. A state machine \\(s\\) with its nested components \\(s_{c}\\) always operates in shared memory even if \\(s\\) is part of \\(C\\) in distributed memory. \\(s\\) has access to local data according to \\(s^+\\). Similarly, each component \\(s_{c}\\) has a dynamic extent denoted by \\(s_{c^+}\\), allowing access to its local data within its specific scope, as illustrated in Figure 1. Restricting the access of data to ancestors facilitates information hiding. For example, a state can access the data of its parent state machine, but a state machine cannot access the data of its states or nested state machines. In Figure 1 state \\(S_{e}\\) has access to variables \\(h\\) and \\(b\\), state \\(S_a\\) can access \\(a\\), and state \\(S_b\\) can access variables \\(c\\), \\(d\\), \\(e\\), and  \\(a\\). However, \\(SM_2\\) can only access variable \\(b\\). Siblings do not have access to each other's data. For instance, \\(S_{d}\\) cannot access any data within \\(SM_{21}\\) or \\(S_{c}\\).</p> <p>When referencing an existing variable within a component \\(c\\), the variable is located by searching within the dynamic extent \\(c^+\\), which encompasses the local data of \\(c\\) and extends to include any ancestor components of \\(c\\). The search proceeds from the local data of \\(c\\) to the local data of its ancestors, and finally to persistent data accessible to the component and its ancestors.</p> <p>Within CSM, data plays a multifaceted role. Data may be declared lexically or created dynamically, and data can be manipulated through actions. Data may be stored locally within a component or persisted globally. Expressions provide fundamental data transformation operations, such as selecting properties from objects, performing calculations or filtering, and invoking utility functions. The versatility of expressions extends to their usage in diverse scenarios. For example, expressions can facilitate gathering input data for service invocations, express guard conditions, or be instrumental in manipulating data objects directly.</p>"},{"location":"csm-specifications/data/","title":"Data","text":""},{"location":"csm-specifications/data/#context","title":"Context","text":"<p>A Context construct is used to lexically declare data within a certain scope (see dynamic extent), data may be persistent, local, or static.</p> <ul> <li>Persistent data is available persistently throughout and possibly outside the collaborative state machine.</li> <li>Local data is restricted to a subset of components of the collaborative state machine.</li> <li>Static data is specific to states.</li> </ul> <p><pre><code>new Context {\n  variables {\n    new ContextVariable {...}...\n  }\n}\n</code></pre> Listing 1: A ContextVariable construct (we use ... to denote a placeholder for construct keywords, or multiple instances of a construct).</p> <p>Note</p> <p>The value of a variable is defined through an expression.</p> <p>The following keywords can/must be provided:</p> Keyword Description Type Optional variables Collection of variables declaring data. list of Variable No"},{"location":"csm-specifications/data/#variables","title":"variables","text":"<p>The variables keyword is used to declare variables. Their scope and lifetime are bound to the associated scope defined by the persistentData, localData, or staticData keyword.</p>"},{"location":"csm-specifications/data/#contextvariable","title":"ContextVariable","text":"<p>A variable declares data, it does so by providing an expression that, when evaluated, results in a data value.</p> <p>Whether a variable is in scope is dependent on how it is declared, see dynamic extent.</p> <p><pre><code>new ContextVariable {\n  name = \"variableName\"\n  value = \"1\"\n}\n</code></pre> Listing 2: A ContextVariable construct.</p> <p>The following keywords can/must be provided:</p> Keyword Description Type Optional name Name of the variable. string No value Value expression. Expression No"},{"location":"csm-specifications/data/#name","title":"name","text":"<p>The name keyword specifies the name of the variable. It serves to reference the variable.</p> <p>Rule</p> <p>Within a scope, the name of a variable must be unique.</p> <p>Info</p> <p>The validity of a variable name is implementation-specific.</p>"},{"location":"csm-specifications/data/#value","title":"value","text":"<p>The value keyword specifies the value expression of the variable. When evaluated, the value expression yields the variable's value. </p> <p>Info</p> <p>Evaluation of a value expression is implementation-specific.</p>"},{"location":"csm-specifications/data/#contextvariablereference","title":"ContextVariableReference","text":"<p>A variable may be referenced through a variable reference.</p> <p><pre><code>new ContextVariableReference {\n  reference = \"photoPath\"\n}\n</code></pre> Listing 3: A ContextVariableReference construct.</p> <p>The following keywords can/must be provided:</p> Keyword Description Type Optional reference Name of the referenced variable. Variable.name No"},{"location":"csm-specifications/data/#reference","title":"reference","text":"<p>The reference keyword specifies the name of the variable that is referenced.</p> <p>Rule</p> <p>The variable reference must be an existing variable in scope.</p>"},{"location":"csm-specifications/event/","title":"Event","text":""},{"location":"csm-specifications/event/#event","title":"Event","text":"<p>Events are raised and handled by state machines in the collaborative state machine and are matched based on their name.</p> <p>Events fall into three categories: internal, external, and global.</p> <p>Internal events are exclusively handled by the state machine that raised them and not seen by other state machines. External events are received by state machines that have subscribed to the events raised by other  state machines. This linkage introduces decentralization, allowing state machines to dynamically subscribe to events of interest raised by other state machines. Global events are not tied to any specific source state  machine and are universally seen by every state machine. This universal handling establishes a global  communication channel within the application. </p> <p>A raised event may contain data transmitted to the receiver; an expression is used to gather the data to  include with the event.</p> <p>When a state machine processes the received event and takes a transition, the event data is assigned to the  current state's local data using the name and value of each provided context variable.</p> <p>This overrides existing variables or creates new variables if they don't exist within the dynamic extent.</p> <p><pre><code>new Event {\n  name = \"e1\"\n  channel = \"global\"\n  data = new Listing[ContextVariable] {...}\n}\n</code></pre> Listing 9: An Event construct.</p> <p>The following keywords can/must be provided:</p> Keyword Description Type Optional name Event name. string No channel Event channel. channel No data Event data. list of Variable Yes"},{"location":"csm-specifications/event/#name","title":"name","text":"<p>The name keyword specifies the event name. Events are matched according to their name. Event names may be re-used.</p> <p>Info</p> <p>The validity of the event name is implementation-specific.</p>"},{"location":"csm-specifications/event/#channel","title":"channel","text":"<p>The channel keyword specifies the event channel of the raised event.</p> <p>The event channel is a string enumeration and must be one of the following:</p> <ul> <li>internal</li> <li>external</li> <li>global</li> </ul>"},{"location":"csm-specifications/event/#data","title":"data","text":"<p>The data keyword specifies the event data contained within the event.</p> <p>Event data will be assigned to the local data of the state machine's current state which processes the event and takes a transition.</p> <p>Event data can be accessed inside expressions by their variable names, with event data variables prefixed by a $ to indicate their special status compared to context variables. The lifetime of event data is bound to the transition following the event and any subsequently executed actions.</p>"},{"location":"csm-specifications/execution-model/","title":"Execution model","text":"<p>This section defines the CSM execution model. The execution model is defined as the execution of an individual state machine. A collaborative state machine containing multiple (nested) state machines will concurrently execute each individual state machine according to the execution model.</p> <p>A state machine instance is associated with a status \\(\\mu = \\langle c^+, \\Gamma, \\Theta \\rangle\\) that captures its current situation, including its dynamic extent \\(c^+\\), input events \\(\\Gamma\\), and active configuration \\(\\Theta\\).</p> <p>The active configuration \\(\\Theta\\) of the state machine is the set of states \\(s \\in S\\) that are currently active. The CSM step algorithm aims to produce a new status according to changes in the state machine's environment that the state machine responds to.</p> <p>The step algorithm reaches a new status by performing a step. We say that a step consists of an arbitrary number of micro-steps and that a step is completed yielding a new status whenever no micro-step exists for the executed step.</p> <p>The CSM execution model adheres to the following principles:</p> <ol> <li>Changes that occur during a step are effective immediately.</li> <li>An event is available during one step only and becomes unavailable upon completion of the step where it is    handled.</li> <li>A state machine is considered alive if the active configuration contains no terminal state.</li> <li>The execution of a step and a micro-step may take time.</li> <li>Actions defined are executed sequentially; a successive action is executed when the preceding action is    completed.</li> <li>One state must be active in the active configuration.</li> </ol> <p>Principle 1 serves to ensure that changes to the state machine's status take effect immediately, avoiding non-determinism by committing changes without delay, thus maintaining consistency and predictability in the state machine's behavior.</p> <p>Principle 2 serves to prevent redundant processing of events within a single step, ensuring that each event is handled exactly once. By making events unavailable after processing in a step, this principle maintains the integrity of event-driven behavior and avoids potential inconsistencies.</p> <p>Principle 3 serves to define the lifetime of a state machine based on the absence of terminal states in its active configuration. By considering a state machine alive if it has states to transition through, this principle ensures that execution continues until a terminal state is reached, maintaining the ongoing functionality of the state machine.</p> <p>Principle 4 serves to acknowledge the potential time consumption during the execution of steps and micro-steps. By recognizing that execution may take time, this principle allows for accommodating delays caused by various factors, ensuring that the execution model remains robust and capable of handling real-world scenarios where computational or external dependencies may affect execution time.</p> <p>Principle 5 serves to enforce the sequential execution of actions defined within the state machine. By ensuring that each action is executed only after the completion of the preceding action, this principle maintains determinism and prevents race conditions or inconsistencies that could arise from concurrent execution of actions, thereby preserving the integrity of state transitions and overall system behavior.</p> <p>Principle 6 serves to avoid non-determinism, i.e., \\(|\\{s \\in \\theta \u2223 s \\text{ is active}\\}|=1\\), by enforcing that only one state can be active in the active configuration at any given time. By ensuring that the active configuration always contains exactly one active state, this principle prevents ambiguity in state transitions and guarantees predictable behavior within the state machine.</p>"},{"location":"csm-specifications/execution-model/#step-algorithm","title":"Step algorithm","text":"<p>We define the step algorithm as follows.</p> <p>procedure ExecuteStep</p> <ul> <li>Input Given the status \\(\\mu\\) of a state machine.</li> <li> <p>Ouput Provide a new status \\(\\mu\\) of the state machine.</p> <ol> <li>\\(\\textbf{while } \\Theta \\neq \\emptyset \\textbf{ do}\\)<ol> <li>\\(x \\leftarrow \\text{Pop(}\\Theta\\text{)}\\)</li> <li>\\(\\text{Handle(}x, \\mu\\text{)}\\)</li> </ol> </li> </ol> </li> </ul> <p>Here, 1.1 ensures that events in the event queue are removed before handling, and 1.2 ensures that the status is updated according to the behavior that follows from events in the event queue.</p> <p>Before executing a single step, \\(\\Theta\\) is updated with respect to any input events in the environment or collaborative state machine. External events, provided by the environment, are added to \\(\\Theta\\) before the execution of a step. Timeout events are treated as external events.</p> <p>We define the Handle procedure as follows.</p> <p>procedure Handle</p> <ul> <li>Input Given an input event \\(x\\) and status \\(\\mu\\).</li> <li> <p>Output Provide an updated status \\(\\mu\\) according to the event.</p> <ol> <li>Select the active on transition \\(t\\), given \\(x\\) and \\(\\mu\\), or \\(\\emptyset\\) in case no active on transition exists.</li> <li>\\(\\textbf{while } \\delta \\neq \\emptyset \\textbf{ do}\\)<ol> <li>If \\(\\delta\\) is an external transition.<ol> <li>Cancel any while actions of the states exited due to \\(\\delta\\).</li> <li>Execute the exit actions of the states exited due to \\(\\delta\\).</li> <li>Execute the actions of \\(\\delta\\).</li> <li>Execute the entry actions of the states entered due to \\(\\delta\\).</li> <li>Execute the while actions of the states entered due to \\(\\delta\\).</li> <li>Update the activate configuration.</li> <li>Set \\(\\delta\\) the active always transition or \\(\\emptyset\\) in case no active always transition  exists.</li> </ol> </li> <li>Otherwise.<ol> <li>Execute the actions of \\(\\delta\\).</li> </ol> </li> </ol> </li> </ol> </li> </ul> <p>An on transition is selected (active) iff its source state (the state from which the transition starts) is the active state, its guard conditions evaluates to true, and \\(x\\) is the event that would trigger the transition.</p> <p>An always transition is selected iff its source state (the state from which the transition starts) is the active state and its guard condition evaluates to true.</p> <p>The selection of a transition must yield exactly one transition. Conflicts arise whenever one event dictates that the state machine should make two atomic states active. This is invalid and will result in non-determinism.</p>"},{"location":"csm-specifications/expression/","title":"Expression","text":""},{"location":"csm-specifications/expression/#expression","title":"Expression","text":"<p>An expression represents an evaluable one-line expression that serves to produce an output value.</p> <p>Expressions are used throughout CSML to represent boolean expressions as well as data expressions. Depending  on the expression language supported by the runtime system implementation, additional functionality may be  available, such as the execution of functions, boolean logic, or arithmetic.</p> <p>An expression is a string that is evaluated to acquire a certain value. </p> <p><pre><code>\"5+5+v\"\n</code></pre> Listing 4: An Expression construct.</p> <p>Info</p> <p>The evaluation of an expression, e.g., the supported syntax, is implementation-specific.</p>"},{"location":"csm-specifications/guard/","title":"Guard","text":""},{"location":"csm-specifications/guard/#guard","title":"Guard","text":"<p>A guard is an expression that evaluates to a boolean value. Guards are used within transitions to determine whether a transition is taken.</p> <p><pre><code>new Guard {\n  expression = \"v==5\"\n}\n</code></pre> Listing 5: A Guard construct.</p> <p>The following keywords can/must be provided:</p> Keyword Description Type Optional expression The guard expression. Expression No"},{"location":"csm-specifications/guard/#expression","title":"expression","text":"<p>The expression keyword specifies the guard expression.</p> <p>Rule</p> <p>The guard expression must evaluate to a boolean value.</p>"},{"location":"csm-specifications/state-machine/","title":"State machine","text":""},{"location":"csm-specifications/state-machine/#statemachine","title":"StateMachine","text":"<p>The purpose of a state machine is to model event-driven execution behavior across the computing continuum by  enabling transitions between states or by accommodating nested state machines that are executed concurrently.</p> <p>Nested state machines allow a state machine to express concurrent behavior while providing mechanisms to observe and influence the execution of the parent state machine. They begin execution simultaneously with the parent state machine.</p> <p>A state machine consists of one or more states, which are reached through state transitions. At any given moment, only one state within a state machine is active, while all other states remain inactive.</p> <p>As with collaborative state machines, local and persistent data can be declared within a state machine.</p> <p><pre><code>new StateMachine {\n  name = \"SM2\"\n  states {\n    new State {...}...\n  }\n  stateMachines {\n    new StateMachine {...}...\n  }\n  localData = new Context {...}\n  persistentData = new Context {...}\n}\n</code></pre> Listing 7: A StateMachine construct.</p> <p>The following keywords can/must be provided:</p> Keyword Description Type Optional name Name of the state machine. string No states Collection of states. list of State No stateMachines Collection of state machines. list of StateMachine No localData Local data. Context Yes persistentData Persistent data. Context Yes"},{"location":"csm-specifications/state-machine/#name","title":"name","text":"<p>The name keyword specifies the name of the state machine and may be used for diagnostic purposes or referencing.</p> <p>The name of a state machine is not referenced inside a description.</p> <p>Info</p> <p>The validity of a name is implementation-specific.</p>"},{"location":"csm-specifications/state-machine/#states","title":"states","text":"<p>The states keyword is used to specify the collection of atomic states included in the state machine.</p> <p>Atomic states are described using the State construct.</p> <p>Rule</p> <p>At least one state must be declared.</p> <p>Rule</p> <p>State.names must be unique.</p> <p>Rule</p> <p>Exactly one initial state must be declared.</p> <p>Rule</p> <p>Initial states must not have inward transitions.</p> <p>Rule</p> <p>Terminal states must not have outward transitions.</p> <p>Rule</p> <p>Every state must be reachable (it must have a transition leading into it, or it must be the initial  state).</p>"},{"location":"csm-specifications/state-machine/#statemachines","title":"stateMachines","text":"<p>The stateMachines keyword is used to specify the collection of nested state machines.</p> <p>Nested state machines are described using the StateMachine construct.</p>"},{"location":"csm-specifications/state-machine/#localdata-persistentdata","title":"localData / persistentData","text":"<p>The localData and persistentData keywords allow for lexically declaring respectively the local and persistent data at the state machine level.</p> <p>Data described at the state machine level is accessible from the state machine and any component hierarchically below it, see dynamic extent.</p>"},{"location":"csm-specifications/state/","title":"State","text":""},{"location":"csm-specifications/state/#state","title":"State","text":"<p>A state represents a potentially active state, which can be activated by entering through a state transition and can be initial, terminal, or neither (intermediate).</p> <p>There must be exactly one initial state within a state machine. A terminal state, of which multiple can exist, indicates the end of the lifecycle of the containing state machine.</p> <p>State transitions are specified as always or on transitions. Always transitions, possibly guarded with expressions, are taken without events. On-event transitions drive the event-driven nature of state machines, allowing a state transition based on a received event.</p> <p>Events may be generated from the state machine itself, other state machines, as well as from the environment external to CSM (for instance, an external application or device). Actions executed in a state include entry and exit actions upon entering or exiting the state. While actions are executed while the state is active. Timed actions are declared using the after keyword.</p> <p>Like other constructs, a state allows for lexically declaring local, static, and persistent data. An additional type of data, static data, utilizes the capability of the state for re-entry, allowing data to retain their values between exiting and re-entering the state.</p> <p><pre><code>new State {\n  name = \"Sa\"\n  initial = true\n  terminal = false\n  entry {\n    new Action {...}...\n  }\n  exit {\n    new Action {...}...\n  }\n  while {\n    new Action {...}...\n  }\n  after {\n    new Action {...}...\n  }\n  on {\n    new OnTransition {...}...\n  }\n  always {\n    new Transition{ ... }...\n  }\n  localData = new Context {...}\n  persistentData = new Context {...}\n  staticData = new Context {...}\n}\n</code></pre> Listing 8: A State construct.</p> <p>The following keywords can/must be provided:</p> Keyword Description Type Optional name Name of the state. string No initial Initial flag of the state. boolean Yes terminal Terminal flag of the state. boolean Yes entry Entry actions. list of Action Yes exit Exit actions. list of Action Yes while While actions. list of Action Yes after After actions. list of TimeoutAction Yes on On event transitions. list of OnTransition Yes always Always transitions. list of Transition Yes localData Local data. Context Yes persistentData Persistent data. Context Yes staticData Static data. Context Yes"},{"location":"csm-specifications/state/#name","title":"name","text":"<p>The name keyword specifies the name of the state and may be used for diagnostic purposes or referencing.</p> <p>A state's name is referenced throughout the state machine to indicate the transition target.</p> <p>Info</p> <p>The validity of a name is implementation-specific.</p>"},{"location":"csm-specifications/state/#initial","title":"initial","text":"<p>The initial keyword specifies whether a state is the initial state of the containing state machine.</p> <p>Rule</p> <p>Exactly one initial state must be declared.</p> <p>Rule</p> <p>Initial states must not have inward transitions.</p>"},{"location":"csm-specifications/state/#terminal","title":"terminal","text":"<p>The terminal keyword specifies whether a state is a terminal state of the containing state machine. Multiple states may be declared terminal.</p> <p>Rule</p> <p>Terminal states must not have outward transitions.</p>"},{"location":"csm-specifications/state/#entry-exit-while-after","title":"entry / exit / while / after","text":"<p>The entry keyword specifies the actions executed upon entry of the state.</p> <p>The exit keyword specifies the actions executed upon exiting the state.</p> <p>The while keyword specifies the actions executed while in a state.</p> <p>The after keyword specifies the actions executed upon a timeout.</p> <p>Actions executed within a state have state scope, see dynamic extent.</p> <p>Rule</p> <p>An action reference must be a valid action name.</p>"},{"location":"csm-specifications/state/#on","title":"on","text":"<p>The on keyword specifies the transitions that can occur based on events.</p> <p>Rule</p> <p>The referenced event in an on-transition must be raised within the collaborative state machine.</p>"},{"location":"csm-specifications/state/#always","title":"always","text":"<p>The always keyword specifies the transitions that can occur regardless of raised events.</p>"},{"location":"csm-specifications/state/#localdata-persistentdata-staticdata","title":"localData / persistentData / staticData","text":"<p>The localData, persistentData, and staticData keywords allow for lexically declaring respectively the local, persistent, and static data at the state machine level.</p> <p>Static data is unique to states and is available after re-entry of a state.</p> <p>Data described at the state level is accessible from the state machine and any component hierarchically below it, see dynamic extent.</p>"},{"location":"csm-specifications/transition/","title":"Transition","text":""},{"location":"csm-specifications/transition/#transition","title":"Transition","text":"<p>A state transition enables the transitioning between the states of a state machine. The result of a state  transition is exiting the currently active state and entering the newly active state.</p> <p>CSML supports external transitions, using the target keyword to specify a target state towards which the transition is directed within the same state machine. A state may externally transition into itself by declaring a transition with its state name.</p> <p>Optionally, the target state may be omitted, leading to an internal transition. In this case, the state machine stays in its current state, bypassing the execution of any actions triggered by entering or exiting a state while still carrying out the transition actions.</p> <p>Guard conditions are provided as expressions in the context of transitions. A guard expression \\(E : \\mathbb{R}^n \\to \\{\\text{true}, \\text{false}\\}\\) takes the form where \\(\\mathbb{R}^n\\) represents the domain, consisting of all variables in scope, see dynamic extent.</p> <p>To initiate a transition, the conjunction of all guard expressions must collectively evaluate to true. The actions keyword is used to specify the actions executed when the transition is taken.</p> <p><pre><code>new Transition {\n  target = \"Sa\"\n  guards {\n    new Guard {...}...\n  }\n  actions {\n    new Action {...}...\n  }\n  else = \"Sb\"\n}\n</code></pre> Listing 10: A Transition construct.</p> <p>Rule</p> <p>Transition guards must be mutually exclusive to ensure determinism, so that at most one transition can be  triggered from any given state at a time.</p> <p>The following keywords can/must be provided:</p> Keyword Description Type Optional target Target state name. State.name No guards Guard conditions. list of Guard Yes actions Transition actions. list of Action Yes else Else target. State.name Yes"},{"location":"csm-specifications/transition/#ontransition","title":"OnTransition","text":"<p>The on-transition construct is a specialization of the transition construct, adding the event keyword that specifies the event that triggers the transition.</p> <p><pre><code>new OnTransition {\n  event = \"e1\"\n  target = \"Sa\"\n  guards {\n    new Guard {...}...\n  }\n  actions {\n    new Action {...}...\n  }\n  else = \"Sb\"\n}\n</code></pre> Listing 11: An OnTransition construct.</p> <p>The following keywords can/must be provided:</p> Keyword Description Type Optional event Event responding to. string No"},{"location":"csm-specifications/transition/#target","title":"target","text":"<p>The target keyword specifies the State.name to transition into.</p> <p>Rule</p> <p>The target state name must be valid.</p>"},{"location":"csm-specifications/transition/#guards","title":"guards","text":"<p>The guards keyword specifies the guard conditions of the transition. All guard expressions must evaluate to boolean true for the transition to be taken.</p> <p>Rule</p> <p>The guard expression must evaluate to boolean true or false.</p>"},{"location":"csm-specifications/transition/#actions","title":"actions","text":"<p>The actions keyword specifies the actions executed as part of the transition. Actions may be declared in-line, in which case an action name is not required. Actions may also be referenced by name. Actions executed within a state have state-scope, see dynamic extent.</p> <p>Rule</p> <p>An action reference must be a valid action name.</p>"},{"location":"csm-specifications/transition/#else","title":"else","text":"<p>The else keyword specifies the state to transition into, should the guard condition not evaluate to boolean true.</p> <p>Rule</p> <p>The else state name must be valid.</p>"},{"location":"csm-specifications/transition/#event","title":"event","text":"<p>The event keyword specifies the name of an event that triggers the on-transition.</p> <p>Rule</p> <p>The name of the event must be an event raised within the collaborative state machine.</p>"},{"location":"csm-specifications/version/","title":"Version","text":"<p>Version 3.0.0</p> <p>These are the Collaborative State Machine (CSM) language specifications.</p> <p>These specifications describe the CSM Language (CSML), its syntax, semantics, and execution model. They define how state machines are constructed, how they interact in a collaborative environment, and the rules governing state transitions, events, and inter-state machine communication. Additionally, these specifications provide guidance for implementing CSML-compliant interpreters, compilers, and runtime environments, ensuring  consistent behavior across different platforms and use cases.</p>"},{"location":"develop/contributing/","title":"Contributing","text":"<p>Contributions to the CSM project are highly welcome!</p> <p>There are many ways to get involved \u2014 whether by improving the runtime system, advancing research, or supporting documentation and tutorials.</p>"},{"location":"develop/contributing/#where-to-start","title":"Where to start","text":"<ul> <li> <p>Contributing to Cirrina   Cirrina, the official runtime system for CSM, is available as an open-source project on GitHub.   You can contribute by:</p> <ul> <li>Fixing bugs \ud83d\udc1e</li> <li>Adding new features \u2728</li> <li>Improving performance \u26a1</li> <li>Enhancing documentation \ud83d\udcd6</li> </ul> </li> <li> <p>Research \ud83d\udcda   If you use CSM in your research or build on our publications, your work is a valuable contribution. Relevant   publications can be found in our Publications.</p> </li> <li> <p>Documentation and Tutorials \ud83d\udcdd   Improving tutorials, examples, and reference documentation helps make CSM more accessible to new users.  </p> </li> </ul>"},{"location":"develop/contributing/#contributing-to-cirrina","title":"Contributing to Cirrina","text":"<p>Cirrina is implemented in Java \u2615 and Kotlin \ud83d\udc9c, with Kotlin as the preferred language.  </p> <p>Contributions are submitted via pull requests from forks of the repository. Please see our  Contribution Guide for details.  </p> <p>Info</p> <p>For major changes or new features, please open a GitHub issue to align with the project roadmap.</p> <p>Info</p> <p>Broader discussions related to the CSM project take place on our  Discussion Board.  </p>"},{"location":"develop/contributing/#research","title":"Research \ud83d\udcd6","text":"<p>We encourage researchers to share new findings, experiments, and insights that extend CSM.</p> <p>These contributions help the project evolve and guide future development.  </p> <p>Note</p> <p>If CSM is part of your research, please cite our primary publication: </p> <p><code>Marlon Etheredge, Thomas Fahringer, Felix Erlacher, Elias Kohler, Stefan Pedratscher, Juan Aznar\\-Poveda, Nishant Saurabh, and Adrien Lebre. Collaborative State Machines: A Better Programming Model for the Cloud\\-Edge\\-IoT Continuum. July 2025. [arXiv:2507.21685](https://arxiv.org/abs/2507.21685), [doi:10.48550/arXiv.2507.21685](https://doi.org/10.48550/arXiv.2507.21685).</code></p>"},{"location":"develop/contributing/#documentation-and-tutorials","title":"Documentation and tutorials \u270d\ufe0f","text":"<p>The CSM project documentation is maintained here on this website.</p> <p>Contributions, corrections, and enhancements are welcome via pull requests to the GitHub repository.  </p>"},{"location":"develop/runtime-system/","title":"Runtime system","text":"<p>Cirrina is the official runtime system of the CSM project.</p> <p>Together with the CSM programming model, it is developed by the  Distributed and Parallel Systems Group at the University of Innsbruck.</p> <p>The runtime system is implemented in Java \u2615 and Kotlin \ud83d\udc9c and is available as an  open-source project on GitHub.  </p>"},{"location":"develop/runtime-system/#key-features","title":"Key features","text":"<ul> <li>High-performance reference implementation \u26a1 of a CSM runtime system.  </li> <li>Designed for heterogeneous environments \ud83c\udf0d \u2014 cloud, edge, and IoT devices.  </li> <li>Supports a wide range of distributed computing scenarios \ud83d\udd00.  </li> <li>Serves as a foundation for research on the CSM method \ud83d\udcda.  </li> <li>Provides a platform that can be extended, adapted, and evaluated \ud83d\udee0\ufe0f by the wider community.  </li> </ul>"},{"location":"develop/runtime-system/#get-involved","title":"Get involved","text":"<p>We welcome contributions from researchers, practitioners, and developers \ud83e\udd1d interested in distributed systems, programming models, and runtime technologies.  </p> <p>For details on how to participate, see Contributing \u2705.</p>"},{"location":"learn/examples/","title":"Examples","text":"<p>The CSM project provides several example use cases of the Cirrina runtime system, implemented in the Pkl CSML language. For a detailed introduction to programming CSM-based applications, see our  Tutorial.</p>"},{"location":"learn/examples/#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Railway Safety System:   A railway crossing controlled by four collaborating state machines that coordinate gates, signals,    and train detection to ensure safety.</li> </ul>"},{"location":"learn/getting-started/","title":"Getting started","text":"<p>Coming soon.</p>"},{"location":"learn/tutorial/","title":"Tutorial","text":"<p>This tutorial introduces CSM through a complete yet compact example: a railway crossing controlled by four collaborating state machines. The goal is to provide a gentle but concrete introduction to the CSM programming model.</p> <p>For the full technical details, see the Specifications, which formally define every aspect of CSM.</p> <p>Traditional service-based approaches emphasize wiring individual services together. CSM takes a different  path. It provides a cohesive way to describe an entire distributed system that can span cloud, edge, and IoT,  this means:</p> <ul> <li> <p>Less time is spent on manually integrating components.</p> </li> <li> <p>Focusing on modeling how the system works as a cohesive whole.</p> </li> <li> <p>Performance optimization becomes an inherent property of the model, rather than an afterthought.</p> </li> </ul> <p>At its core, CSM is about describing highly reactive, state machine-driven applications. Services remain vital, they perform computation and connect to external systems, but they are framed within a model that captures their collaboration, distribution, and semantics. This gives you both the precision of formal modeling and the practicality of building real-world distributed applications.</p> <p>Info</p> <p>This tutorial uses Cirrina's CSML implementation, which is built on top of Apple's Pkl language. For details specific to Pkl itself, please refer to the official Pkl documentation. The complete source code for this tutorial can be found in the Examples. If you're new to the Cirrina runtime, check out Getting Started before  diving into this tutorial.</p>"},{"location":"learn/tutorial/#system-overview","title":"System overview","text":"<p>In this tutorial, we model a railway crossing as a distributed safety system composed of a collaborating state machine. This example illustrates how CSM can capture reactive, distributed behavior in a way that is both precise and intuitive.</p> <p>A single crossing consists of four main components, each with a clear role in ensuring safety:</p> Component Responsibility Bell Provides auditory warnings to approaching traffic Light Provides visual warnings through flashing signals Gate Controls the physical barrier across the road Controller Coordinates the other components based on sensor input <p>Tip</p> <p>The Controller is the manager of the crossing. It does not perform physical actions itself, but it decides when each component should act.</p>"},{"location":"learn/tutorial/#sensors-and-train-positions","title":"Sensors and train positions","text":"<p>The system uses three sensors placed along the track to detect train movement:</p> Sensor Location A Before the crossing B At the crossing C After the crossing <p>Each sensor emits events when a train enters or leaves its detection zone. By combining these signals, the system can determine six key train positions:</p> Train Position Description Away No train in range Approach Train detected by sensor A Close Train between sensor A and B Present Train detected at the crossing (sensor B) Leaving Train between sensor B and C Left Train past sensor C <p>Tip</p> <p>Think of these positions as a \"snapshot\" of the train relative to the crossing. The sequence of snapshots guides the Controller in activating the warning systems.</p> <p>For simplicity, we unify sensor readings into a single event:</p> Event Meaning <code>s</code> Train detected <code>\u00acs</code> Train not detected <p>By tracking these events across the three sensors, the Controller reconstructs the train's journey and ensures that bells, lights, and gates activate and deactivate at the correct moments.</p>"},{"location":"learn/tutorial/#why-this-model-works","title":"Why this model works","text":"<p>CSM allows us to focus on how components collaborate rather than on low-level wiring or implementation details. Each component is represented as a state machine with clearly defined behavior, and the system's overall safety emerges from their interactions.</p> <p>This design is inspired by the classic work of: N.G. Leveson and J.L. Stolzy. Safety Analysis Using Petri Nets. IEEE Transactions on Software Engineering, SE-13(3):386\u2013397, March 1987. doi:10.1109/TSE.1987.233170.</p> <p>Tip</p> <p>In practice, this means you can model complex distributed systems, including cloud, edge, and IoT deployments, without losing sight of the system's reactive logic or operational requirements.</p>"},{"location":"learn/tutorial/#benefits-of-csm","title":"Benefits of CSM","text":"<p>CSM models applications as distributable state machines that collaborate to form a single cohesive system. Each state machine can be deployed where it makes the most sense: on IoT devices near the tracks for immediate reactions, on edge nodes to coordinate behavior across multiple sites, or in the cloud for monitoring, analytics, or compute-intensive tasks that permit non-real-time responses.</p> <p>Using CSM provides several key advantages:</p> <ul> <li>Local responsiveness: Safety-critical actions, such as lowering a gate or activating a bell, happen   immediately without relying on round-trips to the cloud.</li> <li>System-wide semantics: Deployment and scheduling decisions are guided by the CSM model itself, rather   than ad hoc wiring of components.</li> <li>Scalability: Adding new crossings or redistributing workloads requires deploying additional state   machines, not redesigning the entire system.</li> <li>Maintainability: Changes in one component do not require rewriting or manually reconnecting other   components; the model explicitly captures collaboration.</li> <li>Understandability: The runtime clearly knows the system's state and how components interact. This makes   it easier to optimize behavior, monitor the system, debug issues, and even perform formal verification.</li> </ul> <p>Because a collaborative state machine provides a cohesive description of the entire system, a runtime like Cirrina can leverage this information to automatically optimize scheduling, invocation, and placement.</p> <p>Distribution, responsiveness, and performance thus become emergent properties of the model, rather than features that must be manually engineered.</p> <p>Tip</p> <p>Think of CSM as a blueprint for your system. The runtime uses this blueprint to decide where and when each state machine should act, letting you focus on what the system should do rather than on low-level logistics.</p>"},{"location":"learn/tutorial/#defining-the-state-machines","title":"Defining the state machines","text":"<p>The Controller state machine coordinates the other components, following the train's journey through the crossing. Its lifecycle is:</p> <p><code>init \u2192 away \u2192 approach \u2192 close \u2192 present \u2192 leaving \u2192 left</code></p> State Description init Sets initial conditions: lights and bell off, gate raised away Idle, waiting for a train to approach approach Activates lights and bell to warn traffic close Lowers the gate to block the road present Train is at the crossing; safety measures remain active leaving Raises the gate as the train departs left Deactivates lights and bell, returning to idle <p>In CSM, each component is a state machine where events trigger transitions. Events can be raised by other state machines or by the environment (e.g., sensors detecting the train).</p> <p>The diagram below illustrates the collaborative system with the Controller and the Bell, Light, and Gate machines:</p> <p></p> <p>The Bell, Light, and Gate state machines represent the basic actuators of the railway crossing, implementing simple on/off or up/down functionality. Each state corresponds to invoking a service that performs the actual operation; turning on or off the lights, activating or silencing the bell, and raising or lowering the gate.</p> <p>The Gate state machine controls the Bell; when the gate is completely up the bell must be activated, and when the gate is completely down the bell must be deactivated.</p> <p>By modeling these components as independent state machines, CSM makes their behavior explicit and separates control logic from implementation details, allowing the runtime to manage coordination, event delivery, and deployment automatically.</p> <p>This design also highlights one of the core benefits of CSM: flexibility. Services can be implemented in any programming language or platform. In this tutorial, Python and FastAPI are used to provide web-based APIs for each component. However, the same state machine model could be connected to alternative implementations, such as simulated devices for testing, microcontroller-based hardware, or other service protocols, without modifying the model itself.  </p> <p>Furthermore, by embedding each service within a state machine, CSM ensures that interactions are predictable and traceable. Every transition is triggered by an event, whether raised by the  Controller, another state machine, or the environment, making the system's behavior transparent and easy to analyze.</p> <p>The Controller manages the system by raising events that trigger actions in the other machines:</p> Triggered Event Target Machine Action lightOn Light Turn lights on lightOff Light Turn lights off bellOn Bell Activate bell bellOff Bell Deactivate bell gateDown Gate Lower gate gateUp Gate Raise gate <p>Tip</p> <p>The Controller defines what should happen and when. The runtime handles execution, ensuring events reach the target state machines reliably.</p>"},{"location":"learn/tutorial/#declaring-the-collaborative-state-machine","title":"Declaring the collaborative state machine","text":"<p>In CSM, every application begins with a collaborative state machine, which acts as the top-level entity containing one or more individual state machines. This top-level structure defines how the system is composed, coordinates the included state machines, and provides a single entry point for the runtime.</p> <p>A collaborative state machine for our railway crossing example is declared as follows:</p> <pre><code>amends \"csm:Csml\"\nimport \"csm:Csml\"\n\nimport \"crossing.pkl\"\nimport \"bell.pkl\"\nimport \"gate.pkl\"\nimport \"light.pkl\"\n\nname    = \"crossing\"\nversion = \"3.0.0\"\nstateMachines {\n  new crossing.CrossingStateMachine {}\n  new bell.BellStateMachine {}\n  new gate.GateStateMachine {}\n  new light.LightStateMachine {}\n}\n</code></pre> <p>This declaration relies on Cirrina's <code>Csml</code> module (imported as <code>csm:Csml</code>). Every CSML application must define a collaborative state machine, and the module is amended here to provide the <code>name</code>, <code>version</code>, and <code>stateMachines</code> fields that describe the application.</p> Explanation of the fields <ul> <li> <p><code>name</code>   A unique identifier for the collaborative state machine. The runtime uses this name to reference the   collaborative state machine, which is especially important in environments where multiple collaborative   state machines may be deployed simultaneously.</p> </li> <li> <p><code>version</code>   Specifies the version of the CSML language used. This ensures compatibility between the application model   and the runtime system.</p> </li> <li> <p><code>stateMachines</code>   Lists the individual state machines that form the collaborative state machine. Each entry is an instance of   a state machine class, defined in a separate <code>.pkl</code> file and brought in via the <code>import</code> statements. For   example, <code>crossing.CrossingStateMachine</code> represents the Controller state machine, while   <code>bell.BellStateMachine</code>, <code>gate.GateStateMachine</code>, and <code>light.LightStateMachine</code> correspond to the respective   actuator components.</p> </li> </ul> <p>By declaring a collaborative state machine in this way, the runtime gains a complete, structured view of the system: it knows all participating state machines, their class definitions, and can manage event delivery, scheduling, and deployment accordingly.</p> <p>This explicit declaration is fundamental to the CSM approach, making the application composable, distributable, and observable from the very start.</p> <p>Tip</p> <p>The collaborative state machine serves as the container for the entire distributed application. It provides a complete description of all components and their interactions, capturing the event-driven behavior of the system. Using this description, the runtime can enable observability, optimize scheduling, and manage execution without the model losing its reactive semantics.</p>"},{"location":"learn/tutorial/#declaring-the-bell-state-machine","title":"Declaring the Bell state machine","text":"<p>The Bell state machine models the actuation behavior of the railway crossing bell. It responds to the events <code>bellOn</code> and <code>bellOff</code>, transitioning between two states to reflect whether the bell is active or silent.</p> <p>The Bell does not perform the actual work itself. Instead, it delegates the physical operation to external services. Each service has a clear, isolated concern, meaning it can be developed independently as long as it adheres to the expected service type. This separation keeps the state machine focused on managing states and transitions, while computation or integration with external systems is handled by services. The approach simplifies modeling, enhances clarity, and allows flexible, interchangeable service implementations.</p> <p>Note</p> <p>Since the Bell and Light state machines are all simple actuators, they share the same basic state machine structure. For clarity, the code for the other actuator state machines is presented alongside the Bell implementation.</p>"},{"location":"learn/tutorial/#declaring-service-invocation-actions","title":"Declaring service invocation actions","text":"<p>Service calls are described using <code>Csml.InvokeAction</code>. For the Bell state machine, we define two actions:</p> BellLight <pre><code>// Action that invokes a service that turns the bell on.\nconst onAction = new Csml.InvokeAction {\n  serviceType = \"bellOn\"\n}\n\n// Action that invokes a service that turns the bell off.\nconst offAction = new Csml.InvokeAction {\n  serviceType = \"bellOff\"\n}\n</code></pre> <pre><code>// Action that invokes a service that turns the light on.\nconst lightOnAction = new Csml.InvokeAction {\n  serviceType = \"lightOn\"\n}\n\n// Action that invokes a service that turns the light off.\nconst lightOffAction = new Csml.InvokeAction {\n  serviceType = \"lightOff\"\n}\n</code></pre> <p>Each action specifies a service type (<code>serviceType</code>), such as <code>bellOn</code>. Service types define what should be done, while the runtime decides how it is executed.</p> <p>For example, the runtime might select an optimized implementation for high-performance hardware, a lightweight version for constrained devices, or a cost-effective alternative depending on the deployment environment.</p>"},{"location":"learn/tutorial/#declaring-the-state-machine","title":"Declaring the state machine","text":"<p>A state machine is defined by extending <code>Csml.StateMachine</code>.</p> <p>The Bell state machine is declared as follows:</p> BellLight <pre><code>// Bell state machine, manages a bell.\nclass BellStateMachine extends Csml.StateMachine {\n  name = \"bell\"\n  states {\n    // The bell is initially off.\n    new {\n      name    = \"off\"\n      initial = true\n      entry { offAction }\n      on {\n        new {\n          event  = events.bellOn\n          target = \"on\"\n        }\n      }\n    }\n    new {\n      name = \"on\"\n      entry { onAction }\n      on {\n        new {\n          event   = events.bellOn\n          actions { onAction }\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code>// Light state machine, manages a light.\nclass LightStateMachine extends Csml.StateMachine {\n  name = \"light\"\n  states {\n    // The light is initially off.\n    new {\n      name    = \"off\"\n      initial = true\n      entry { lightOffAction }\n      on {\n        new {\n          event  = events.lightOn\n          target = \"on\"\n        }\n      }\n    }\n    new {\n      name = \"on\"\n      entry { lightOnAction }\n      on {\n        new {\n          event   = events.lightOn\n          actions { lightOnAction }\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>This declaration relies on the <code>Csml.StateMachine</code> class, which provides the structure for defining a state machine in CSM. By extending this class, the Bell state machine specifies its name, the states it can occupy, the initial state, entry actions, and how each state responds to incoming events. Each state corresponds to the machine being in a particular configuration, and its behavior is driven entirely by events raised either by the environment or other state machines.</p> Explanation of the fields <ul> <li> <p><code>name</code>   A unique identifier for the state machine. The runtime uses this name to reference the Bell state   machine, which is important when multiple state machines are deployed within the system.</p> </li> <li> <p><code>states</code>   Defines all the states that the Bell state machine can occupy. Each state includes the actions to   execute when entering the state and the transitions that should occur in response to specific events. This   explicit definition allows the runtime to manage state, trigger actions, and coordinate with other state   machines in a predictable, event-driven manner.</p> </li> </ul> <p>Tip</p> <p>Think of the Bell state machine as a reactive component within the collaborative system. It does not perform hardware operations itself; instead, it specifies what should happen when certain events occur. The runtime uses this model to coordinate actions, trigger services, and ensure predictable event-driven behavior.</p>"},{"location":"learn/tutorial/#declaring-a-state","title":"Declaring a state","text":"<p>Looking at a single state more closely:</p> BellLight <pre><code>new {\n  name    = \"off\"\n  initial = true\n  entry { offAction }\n  on {\n    new {\n      event  = events.bellOn\n      target = \"on\"\n    }\n  }\n}\n</code></pre> <pre><code>new {\n  name    = \"off\"\n  initial = true\n  entry { lightOffAction }\n  on {\n    new {\n        event  = events.lightOn\n        target = \"on\"\n    }\n  }\n}\n</code></pre> <p>This declaration relies on the <code>Csml.State</code> class (omitted here since the class type is implied by the <code>states</code> field of the state machine), which provides the structure for defining a state in CSM.</p> <p>Each state machine has one initial state, which it enters when first instantiated, and can have any number of final states, where the machine terminates. All other states are considered intermediate and the machine can transition through them as events occur.</p> <p>A state may define several types of action blocks, such as the entry (<code>entry</code>) actions executed upon entering the state, the exit (<code>exit</code>) actions executed upon leaving the state, the while (<code>while</code>) actions executed continuously while the machine remains in the state, and timeout actions executed at pre-defined intervals, if specified.</p> <p>This structure allows each state to encapsulate its behavior fully, making the state machine predictable, reactive, and easy to reason about.</p> Explanation of the fields <p>Each state has several key properties:</p> <ul> <li> <p><code>name</code>   The unique identifier of the state.</p> </li> <li> <p><code>initial</code>   Marks this state as the starting point when the state machine is first instantiated.</p> </li> <li> <p><code>entry</code>   Actions to execute upon entering the state. In this case, it ensures the bell is off.</p> </li> <li> <p><code>on</code>   Event handlers specifying transitions or additional actions triggered by incoming events. Here, receiving   <code>bellOn</code> transitions the machine to the <code>on</code> state.</p> </li> </ul> <p>The <code>on</code> field is paired with a list of <code>Csml.OnTransition</code> objects, which define on-event  transitions. Each transition is triggered by a received event and can either move the state machine to a new state or remain in the current state (a self-transition).  </p> <p>Transitions can include an action block (<code>actions</code>) that executes one or more actions when the transition occurs. They can also be guarded, meaning the transition only occurs if a specified condition evaluates to <code>true</code>. This allows precise control over when and how state changes happen in response to events.</p> <p>Tip</p> <p>Each state is a self-contained reactive unit. It encapsulates the actions, transitions, and behavior for a specific configuration of the state machine. By clearly defining states and their event-driven responses, you can develop, test, and reason about each part of your system in isolation while ensuring predictable behavior when combined with other states and machines.</p>"},{"location":"learn/tutorial/#declaring-an-event","title":"Declaring an event","text":"<p>In CSM, event names are represented as strings. For convenience and consistency, events are typically stored in variables, making them easy to reference throughout the application. A declaration looks like this:</p> <pre><code>// Raised based on a sensor reading.\nsensor   = \"sensor\"\n\n// Raised when the gate should be up.\ngateUp   = \"gateUp\"\n\n// Raised when the gate should be down.\ngateDown = \"gateDown\"\n\n// Raised when the light should be on.\nlightOn  = \"lightOn\"\n\n// Raised when the light should be off.\nlightOff = \"lightOff\"\n\n// Raised when the bell should be on.\nbellOn  = \"bellOn\"\n\n// Raised when the bell should be off.\nbellOff = \"bellOff\"\n</code></pre>"},{"location":"learn/tutorial/#declaring-the-gate-state-machine","title":"Declaring the Gate state machine","text":"<p>The Gate state machine models the raising and lowering of the railway crossing gate, coordinating closely with the bell to ensure safe operation. Gate movement is initiated via service invocations. Each service invocation can define a done action block, which is executed after the service completes. For example, the done block of the gate-raising action is used to deactivate the bell once the gate is fully raised.</p> <p>Before lowering the gate, the bell should be activated. By leveraging the deterministic order of actions within an action block, the bell can be turned on first, followed immediately by the gate-lowering service.</p> <p>As with other actuators, the Gate delegates the physical work to external services.</p> <p>Tip</p> <p>The Gate, like the Bell and Light, follows a consistent state machine structure. Using the  <code>done</code> block of <code>Csml.InvokeAction</code> allows synchronization between gate operations and related events, such as deactivating the bell.</p>"},{"location":"learn/tutorial/#declaring-actions","title":"Declaring actions","text":"<p>Gate actions are either <code>Csml.InvokeAction</code> or <code>Csml.RaiseAction</code>.</p> <p>We define the following actions:</p> <pre><code>// Action that invokes a service to raise the gate.\nconst gateUpAction = new Csml.InvokeAction {\n  serviceType = \"gateUp\"\n  done {\n    new {\n      name    = events.bellOff\n      channel = \"external\"\n    }\n  }\n}\n\n// Action that raises the bell on event before the gate starts lowering.\nconst raiseBellOnAction = new Csml.RaiseAction {\n  event {\n    name    = events.bellOn\n    channel = \"external\"\n  }\n}\n\n// Action that invokes a service to lower the gate.\nconst gateDownAction = new Csml.InvokeAction {\n  serviceType = \"gateDown\"\n}\n</code></pre> <p>The raise event action is defined using the <code>Csml.RaiseAction</code> class.</p> <ul> <li><code>name</code> Specifies the name of the event to raise.  </li> <li><code>channel</code> Determines where the event is visible. CSM supports several channel types:  <ul> <li><code>internal</code> Handled only within the current state machine.</li> <li><code>external</code> Raised globally but requires explicit subscription by other state machines.</li> <li><code>global</code> Raised globally and automatically received by all state machines.</li> <li><code>peripheral</code> Raised by the environment, typically representing sensors or external inputs . </li> </ul> </li> </ul> <p>Using external channels allows one state machine to notify others within the collaborative state machine. To receive these events, another state machine must explicitly subscribe to the relevant channel, ensuring controlled and predictable inter-machine communication.</p>"},{"location":"learn/tutorial/#declaring-the-state-machine_1","title":"Declaring the state machine","text":"<p>The Gate state machine is declared as follows:</p> <pre><code>class GateStateMachine extends Csml.StateMachine {\n  name = \"gate\"\n  states {\n    // The gate is initially up.\n    new {\n      name    = \"up\"\n      initial = true\n      entry { gateUpAction }\n      on {\n        new {\n          event  = events.gateDown\n          target = \"down\"\n        }\n      }\n    }\n    new {\n      name = \"down\"\n      entry { \n        raiseBellOnAction\n        gateDownAction\n      }\n      on {\n        new {\n          event  = events.gateUp\n          target = \"up\"\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>The <code>up</code> state behaves similarly to the Bell and Light state machines introduced earlier.  </p> <p>The <code>down</code> state, however, includes an entry action block that contains two actions: <code>raiseBellOnAction</code> and  <code>gateDownAction</code>. The <code>raiseBellOnAction</code> ensures the bell is activated before the gate begins lowering, while <code>gateDownAction</code> executes the service invocation to lower the gate.  </p> <p>When the gate is raised, the bell is deactivated through the <code>done</code> action block of the <code>gateUpAction</code>. This sequence ensures that the bell is active for the full duration of the gate movement and that all actions occur in a predictable, event-driven order.</p>"},{"location":"learn/tutorial/#declaring-the-controller-state-machine","title":"Declaring the Controller state machine","text":"<p>Finally, the Controller state machine oversees the Light and Gate state machines by processing events from the nearby sensors (A, B, and C) and transitioning through the sequence:</p> <pre><code>away \u2192 approach \u2192 close \u2192 present \u2192 leaving \u2192 left\n</code></pre> <p>At startup, the Controller enters a state that resets the crossing to a default configuration: the light is off and the gate is raised. Subsequently the Controller reacts to sensor events to manage the arrival, presence, and departure of trains, ensuring the coordinated activation of lights, gates, and bells.</p> <p>The Controller also maintains a local counter that tracks how many trains have passed through the crossing.</p>"},{"location":"learn/tutorial/#declaring-the-actions","title":"Declaring the actions","text":"<p>Controller actions are either <code>Csml.RaiseAction</code> or <code>Csml.AssignAction</code>.</p> <p>We define the following actions:</p> <pre><code>// Action that raises the gate up event.\nconst raiseGateUpAction = new Csml.RaiseAction {\n  event {\n    name    = events.gateUp\n    channel = \"external\"\n  }\n}\n\n// Action that raises the gate down event.\nconst raiseGateDownAction = new Csml.RaiseAction {\n  event {\n    name    = events.gateDown\n    channel = \"external\"\n  }\n}\n\n// Action that raises the light on event.\nconst raiseLightOnAction = new Csml.RaiseAction {\n  event {\n    name    = events.lightOn\n    channel = \"external\"\n  }\n}\n\n// Action that raises the light off event.\nconst raiseLightOffAction = new Csml.RaiseAction {\n  event {\n    name    = events.lightOff\n    channel = \"external\"\n  }\n}\n\n// Action that increments the number of trains passed.\nconst incrementNumTrainsPassed = new Csml.AssignAction {\n  variable = new {\n    name = \"numTrainsPassed\"\n    value = \"numTrainsPassed + 1\"\n  }\n}\n</code></pre> <p>An assign action is created using the <code>Csml.RaiseAction</code> class and is used to update the value of a variable through a defined expression.</p> <p>In this example, the variable <code>numTrainsPassed</code> is incremented by assigning it the output of the expression:</p> <pre><code>numTrainsPassed + 1\n</code></pre> <p>During execution, <code>numTrainsPassed</code> is substituted with its current value, and the result of the expression is stored back into the variable.</p>"},{"location":"learn/tutorial/#declaring-the-guards","title":"Declaring the guards","text":"<p>To ensure that the Crossing only transitions when the train's position actually changes, the transitions of the state machine are guarded. Earlier in this tutorial, we introduced the unified sensor events <code>s</code> and <code>\u00acs</code>, which indicate whether a train is detected or not. These events are used inside guard conditions to make sure transitions occur only when a change in sensor state is observed.</p> <p>The guards are declared as follows:</p> <pre><code>// Guard that passes when the event data ($value) is true.\nconst isEventDataTrueGuard = new Csml.Guard {\n  expression = \"$value == true\"\n}\n\n// Guard that passes when the event data ($value) is false.\nconst isEventDataFalseGuard = new Csml.Guard {\n  expression = \"$value == false\"\n}\n</code></pre> <p>In this case, a special variable <code>$value</code> is used.</p> <p>During event handling, <code>$value</code> is automatically populated with the event's data payload. Events in CSM may carry arbitrary data, which can then be leveraged in guards.  </p> <ul> <li><code>isEventDataTrueGuard</code> \u2192 passes when a train is present at a sensor (<code>s</code>).  </li> <li><code>isEventDataFalseGuard</code> \u2192 passes when a train is absent at a sensor (<code>\u00acs</code>).  </li> </ul>"},{"location":"learn/tutorial/#declaring-the-state-machine_2","title":"Declaring the state machine","text":"<p>Finally, we can declare the Controller state machine that connects all other components of the collaborative state machines as follows:</p> <pre><code>class ControllerStateMachine extends Csml.StateMachine {\n  name = \"controller\"\n  localContext {\n    variables {\n      new {\n        name  = \"numTrainsPassed\"\n        value = \"0\"\n      }\n    }\n  }\n  states {\n    new {\n      name    = \"init\"\n      initial = true\n      entry {\n        raiseLightOffAction\n        raiseGateUpAction\n      }\n      always {\n        new {\n          target = \"away\"\n        }\n      }\n    }\n    new {\n      name = \"away\"\n      on {\n        new {\n          event  = events.sensor\n          target = \"approach\"\n          guards { isEventDataTrueGuard }\n        }\n      }\n    }\n    new {\n      name = \"approach\"\n      entry { raiseLightOnAction }\n      on {\n        new {\n          event  = events.sensor\n          target = \"close\"\n          guards { isEventDataFalseGuard }\n        }\n      }\n    }\n    new {\n      name = \"close\"\n      entry { raiseGateDownAction }\n      on {\n        new {\n          event  = events.sensor\n          target = \"present\"\n          guards { isEventDataTrueGuard }\n        }\n      }\n    }\n    new {\n      name = \"present\"\n      entry { incrementNumTrainsPassed }\n      on {\n        new {\n          event  = events.sensor\n          target = \"leaving\"\n          guards { isEventDataFalseGuard }\n        }\n      }\n    }\n    new {\n      name = \"leaving\"\n      entry { raiseGateUpAction }\n      on {\n        new {\n          event  = events.sensor\n          target = \"left\"\n          guards { isEventDataTrueGuard }\n        }\n      }\n    }\n    new {\n      name = \"left\"\n      entry { raiseLightOffAction }\n      on {\n        new {\n          event  = events.sensor\n          target = \"away\"\n          guards { isEventDataFalseGuard }\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>The <code>localContext</code> keyword defines the local data of a state machine, accessible only within that machine. Besides local data, CSM also supports persistent data (globally accessible across machines) and state-specific static data (retained across state activation and deactivation).</p> <p>A local variable such as <code>numTrainsPassed</code> is declared using <code>Csml.ContextVariable</code>, which specifies:</p> <ul> <li> <p><code>name</code>    The identifier of the variable.</p> </li> <li> <p><code>value</code>   An expression that determines the variable's initial value.</p> </li> </ul>"},{"location":"learn/tutorial/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we built a railway crossing safety system using CSM and the Cirrina CSML implementation. Step by step, we modeled sensors, actuators, and a controller as state machines that together form a predictable, reactive, and distributed system.</p> <p>This example is not just theoretical, it is fully implemented as part of the Cirrina runtime system. You can explore the complete implementation, experiment with the code, and run it yourself in the Examples section.</p> <p>By studying and experimenting with this example, you will gain practical insight into:</p> <ul> <li> <p>How to design state machines for sensors, actuators, and controllers.</p> </li> <li> <p>How collaboration works in CSM, using events, guards, and context variables.</p> </li> <li> <p>How Cirrina executes CSM applications, ensuring predictable and distributed behavior.</p> </li> </ul> <p>We encourage you to explore the example code, adapt it to your own scenarios, and use it as a starting point for experimenting with CSM in real-world applications.</p>"},{"location":"research/publications/","title":"Publications","text":"<p>CSM is a research project.</p> <p>We are actively working on the CSM programming model itself as well as on methods, tools, and runtime support that form its broader ecosystem.</p> <p>The following is a list of publications related to the CSM project.</p> <p>Info</p> <p>The primary publication to cite for CSM is: Marlon Etheredge, Thomas Fahringer, Felix Erlacher, Elias Kohler, Stefan Pedratscher, Juan Aznar-Poveda, Nishant Saurabh, and Adrien Lebre. Collaborative State Machines: A Better Programming Model for the Cloud-Edge-IoT Continuum. July 2025. arXiv:2507.21685, doi:10.48550/arXiv.2507.21685.</p> <p>Additional research on CSM can be found in:</p> <ul> <li>2025 \u2013 Marlon Etheredge, Thomas Fahringer, Felix Erlacher, Elias Kohler, Stefan Pedratscher, Juan Aznar-Poveda, Nishant Saurabh, and Adrien Lebre. Collaborative State Machines: A Better Programming Model for the Cloud-Edge-IoT Continuum. July 2025. arXiv:2507.21685, doi:10.48550/arXiv.2507.21685.</li> <li>2025 \u2013 Juan Aznar Poveda, Marlon Etheredge, Stefan Pedratscher, Patrick K\u00fcnig, and Thomas Fahringer. Nyx: A Fault-Tolerant Fully Distributed Message Queue for the IoT-Edge-Cloud Continuum. In 2025 21st International Conference on Distributed Computing in Smart Systems and the Internet of Things (DCOSS-IoT), 1021\u20131026. June 2025. doi:10.1109/DCOSS-IoT65416.2025.00154.</li> </ul>"},{"location":"research/team/","title":"Team","text":"<p>CSM originated within the Distributed and Parallel Systems Group at the University of Innsbruck and continues to be developed there.</p> <p>The following list presents the current team members actively working on CSM.</p> <ul> <li>    Marlon Etheredge, MSc<sup>1</sup></li> <li>    Univ.-Prof. Dr. Thomas Fahringer<sup>1</sup></li> <li>    Dr. Juan Aznar Poveda</li> <li>    Alexander Zangerle</li> </ul>"},{"location":"research/team/#alumni","title":"Alumni","text":"<p>The following list shows anonymized alumni and their research topics.</p> <ul> <li>BSc, 2024 \u2014 Thesis on distributed event queues.</li> <li>BSc, 2024 \u2014 Thesis on resource management.</li> <li>BSc, 2024 \u2014 Thesis on visual modeling for Cloud-Edge-IoT.</li> <li>MSc, 2024 \u2014 Thesis on innovative extensions of the CSM model and formalization.</li> <li>BSc, 2023 \u2014 Thesis on a CSM implementation.</li> </ul> <ol> <li> <p>For all correspondence concerning CSM.\u00a0\u21a9\u21a9</p> </li> </ol>"}]}